<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (20) -->
<title>CountedCompleter (Java SE 20 &amp; JDK 20 [ad-hoc build])</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: java.util.concurrent, class: CountedCompleter">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="java.util.concurrent.CountedCompleter class">
<meta name="keywords" content="compute()">
<meta name="keywords" content="onCompletion()">
<meta name="keywords" content="onExceptionalCompletion()">
<meta name="keywords" content="getCompleter()">
<meta name="keywords" content="getPendingCount()">
<meta name="keywords" content="setPendingCount()">
<meta name="keywords" content="addToPendingCount()">
<meta name="keywords" content="compareAndSetPendingCount()">
<meta name="keywords" content="decrementPendingCountUnlessZero()">
<meta name="keywords" content="getRoot()">
<meta name="keywords" content="tryComplete()">
<meta name="keywords" content="propagateCompletion()">
<meta name="keywords" content="complete()">
<meta name="keywords" content="firstComplete()">
<meta name="keywords" content="nextComplete()">
<meta name="keywords" content="quietlyCompleteRoot()">
<meta name="keywords" content="helpComplete()">
<meta name="keywords" content="exec()">
<meta name="keywords" content="getRawResult()">
<meta name="keywords" content="setRawResult()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header"><div style="padding: 6px; text-align: center; font-size: 80%; font-family: DejaVu Sans, Arial, Helvetica, sans-serif; font-weight: normal;">This specification is not final and is subject to change. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java20speclicense.html">license terms</a>.</div>
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 9px;"><strong>Java SE 20 &amp; JDK 20</strong> <br><strong>DRAFT 20-internal-2022-07-19-1311514.jlaskey...</strong></div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/CountedCompleter.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li>Field</li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#constructor-detail">Constr</a></li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">java.util.concurrent</a></div>
<h1 title="Class CountedCompleter" class="title">Class CountedCompleter&lt;T&gt;</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="../../lang/Object.html" title="class in java.lang">java.lang.Object</a>
<div class="inheritance"><a href="ForkJoinTask.html" title="class in java.util.concurrent">java.util.concurrent.ForkJoinTask</a>&lt;T&gt;
<div class="inheritance">java.util.concurrent.CountedCompleter&lt;T&gt;</div>
</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - the type of the result of the completer</dd>
</dl>
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="../../io/Serializable.html" title="interface in java.io">Serializable</a></code>, <code><a href="Future.html" title="interface in java.util.concurrent">Future</a>&lt;T&gt;</code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public abstract class </span><span class="element-name type-name-label">CountedCompleter&lt;T&gt;</span>
<span class="extends-implements">extends <a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt;</span></div>
<div class="block">A <a href="ForkJoinTask.html" title="class in java.util.concurrent"><code>ForkJoinTask</code></a> with a completion action performed when
 triggered and there are no remaining pending actions.
 CountedCompleters are in general more robust in the
 presence of subtask stalls and blockage than are other forms of
 ForkJoinTasks, but are less intuitive to program.  Uses of
 CountedCompleter are similar to those of other completion based
 components (such as <a href="../../nio/channels/CompletionHandler.html" title="interface in java.nio.channels"><code>CompletionHandler</code></a>)
 except that multiple <em>pending</em> completions may be necessary
 to trigger the completion action <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>,
 not just one.
 Unless initialized otherwise, the <a href="#getPendingCount()">pending
 count</a> starts at zero, but may be (atomically) changed using
 methods <a href="#setPendingCount(int)"><code>setPendingCount(int)</code></a>, <a href="#addToPendingCount(int)"><code>addToPendingCount(int)</code></a>, and
 <a href="#compareAndSetPendingCount(int,int)"><code>compareAndSetPendingCount(int, int)</code></a>. Upon invocation of <a href="#tryComplete()"><code>tryComplete()</code></a>, if the pending action count is nonzero, it is
 decremented; otherwise, the completion action is performed, and if
 this completer itself has a completer, the process is continued
 with its completer.  As is the case with related synchronization
 components such as <a href="Phaser.html" title="class in java.util.concurrent"><code>Phaser</code></a> and <a href="Semaphore.html" title="class in java.util.concurrent"><code>Semaphore</code></a>, these methods
 affect only internal counts; they do not establish any further
 internal bookkeeping. In particular, the identities of pending
 tasks are not maintained. As illustrated below, you can create
 subclasses that do record some or all pending tasks or their
 results when needed.  As illustrated below, utility methods
 supporting customization of completion traversals are also
 provided. However, because CountedCompleters provide only basic
 synchronization mechanisms, it may be useful to create further
 abstract subclasses that maintain linkages, fields, and additional
 support methods appropriate for a set of related usages.

 <p>A concrete CountedCompleter class must define method <a href="#compute()"><code>compute()</code></a>, that should in most cases (as illustrated below), invoke
 <code>tryComplete()</code> once before returning. The class may also
 optionally override method <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>
 to perform an action upon normal completion, and method
 <a href="#onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)"><code>onExceptionalCompletion(Throwable, CountedCompleter)</code></a> to
 perform an action upon any exception.

 <p>CountedCompleters most often do not bear results, in which case
 they are normally declared as <code>CountedCompleter&lt;Void&gt;</code>, and
 will always return <code>null</code> as a result value.  In other cases,
 you should override method <a href="#getRawResult()"><code>getRawResult()</code></a> to provide a
 result from <code>join(), invoke()</code>, and related methods.  In
 general, this method should return the value of a field (or a
 function of one or more fields) of the CountedCompleter object that
 holds the result upon completion. Method <a href="#setRawResult(T)"><code>setRawResult(T)</code></a> by
 default plays no role in CountedCompleters.  It is possible, but
 rarely applicable, to override this method to maintain other
 objects or fields holding result data.

 <p>A CountedCompleter that does not itself have a completer (i.e.,
 one for which <a href="#getCompleter()"><code>getCompleter()</code></a> returns <code>null</code>) can be
 used as a regular ForkJoinTask with this added functionality.
 However, any completer that in turn has another completer serves
 only as an internal helper for other computations, so its own task
 status (as reported in methods such as <a href="ForkJoinTask.html#isDone()"><code>ForkJoinTask.isDone()</code></a>)
 is arbitrary; this status changes only upon explicit invocations of
 <a href="#complete(T)"><code>complete(T)</code></a>, <a href="ForkJoinTask.html#cancel(boolean)"><code>ForkJoinTask.cancel(boolean)</code></a>,
 <a href="ForkJoinTask.html#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> or upon
 exceptional completion of method <code>compute</code>. Upon any
 exceptional completion, the exception may be relayed to a task's
 completer (and its completer, and so on), if one exists and it has
 not otherwise already completed. Similarly, cancelling an internal
 CountedCompleter has only a local effect on that completer, so is
 not often useful.

 <p><b>Sample Usages.</b>

 <p><b>Parallel recursive decomposition.</b> CountedCompleters may
 be arranged in trees similar to those often used with <a href="RecursiveAction.html" title="class in java.util.concurrent"><code>RecursiveAction</code></a>s, although the constructions involved in setting
 them up typically vary. Here, the completer of each task is its
 parent in the computation tree. Even though they entail a bit more
 bookkeeping, CountedCompleters may be better choices when applying
 a possibly time-consuming operation (that cannot be further
 subdivided) to each element of an array or collection; especially
 when the operation takes a significantly different amount of time
 to complete for some elements than others, either because of
 intrinsic variation (for example I/O) or auxiliary effects such as
 garbage collection.  Because CountedCompleters provide their own
 continuations, other tasks need not block waiting to perform them.

 <p>For example, here is an initial version of a utility method that
 uses divide-by-two recursive decomposition to divide work into
 single pieces (leaf tasks). Even when work is split into individual
 calls, tree-based techniques are usually preferable to directly
 forking leaf tasks, because they reduce inter-thread communication
 and improve load balancing. In the recursive case, the second of
 each pair of subtasks to finish triggers completion of their parent
 (because no result combination is performed, the default no-op
 implementation of method <code>onCompletion</code> is not overridden).
 The utility method sets up the root task and invokes it (here,
 implicitly using the <a href="ForkJoinPool.html#commonPool()"><code>ForkJoinPool.commonPool()</code></a>).  It is
 straightforward and reliable (but not optimal) to always set the
 pending count to the number of child tasks and call <code>
 tryComplete()</code> immediately before returning.

 <pre> <code>
 public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
   class Task extends CountedCompleter&lt;Void&gt; {
     final int lo, hi;
     Task(Task parent, int lo, int hi) {
       super(parent); this.lo = lo; this.hi = hi;
     }

     public void compute() {
       if (hi - lo &gt;= 2) {
         int mid = (lo + hi) &gt;&gt;&gt; 1;
         // must set pending count before fork
         setPendingCount(2);
         new Task(this, mid, hi).fork(); // right child
         new Task(this, lo, mid).fork(); // left child
       }
       else if (hi &gt; lo)
         action.accept(array[lo]);
       tryComplete();
     }
   }
   new Task(null, 0, array.length).invoke();
 }</code></pre>

 This design can be improved by noticing that in the recursive case,
 the task has nothing to do after forking its right task, so can
 directly invoke its left task before returning. (This is an analog
 of tail recursion removal.)  Also, when the last action in a task
 is to fork or invoke a subtask (a "tail call"), the call to <code>
 tryComplete()</code> can be optimized away, at the cost of making the
 pending count look "off by one".

 <pre> <code>
     public void compute() {
       if (hi - lo &gt;= 2) {
         int mid = (lo + hi) &gt;&gt;&gt; 1;
         setPendingCount(1); // looks off by one, but correct!
         new Task(this, mid, hi).fork(); // right child
         new Task(this, lo, mid).compute(); // direct invoke
       } else {
         if (hi &gt; lo)
           action.accept(array[lo]);
         tryComplete();
       }
     }</code></pre>

 As a further optimization, notice that the left task need not even exist.
 Instead of creating a new one, we can continue using the original task,
 and add a pending count for each fork.  Additionally, because no task
 in this tree implements an <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> method,
 <code>tryComplete</code> can be replaced with <a href="#propagateCompletion()"><code>propagateCompletion()</code></a>.

 <pre> <code>
     public void compute() {
       int n = hi - lo;
       for (; n &gt;= 2; n /= 2) {
         addToPendingCount(1);
         new Task(this, lo + n/2, lo + n).fork();
       }
       if (n &gt; 0)
         action.accept(array[lo]);
       propagateCompletion();
     }</code></pre>

 When pending counts can be precomputed, they can be established in
 the constructor:

 <pre> <code>
 public static &lt;E&gt; void forEach(E[] array, Consumer&lt;E&gt; action) {
   class Task extends CountedCompleter&lt;Void&gt; {
     final int lo, hi;
     Task(Task parent, int lo, int hi) {
       super(parent, 31 - Integer.numberOfLeadingZeros(hi - lo));
       this.lo = lo; this.hi = hi;
     }

     public void compute() {
       for (int n = hi - lo; n &gt;= 2; n /= 2)
         new Task(this, lo + n/2, lo + n).fork();
       action.accept(array[lo]);
       propagateCompletion();
     }
   }
   if (array.length &gt; 0)
     new Task(null, 0, array.length).invoke();
 }</code></pre>

 Additional optimizations of such classes might entail specializing
 classes for leaf steps, subdividing by say, four, instead of two
 per iteration, and using an adaptive threshold instead of always
 subdividing down to single elements.

 <p><b>Searching.</b> A tree of CountedCompleters can search for a
 value or property in different parts of a data structure, and
 report a result in an <a href="atomic/AtomicReference.html" title="class in java.util.concurrent.atomic"><code>AtomicReference</code></a> as
 soon as one is found. The others can poll the result to avoid
 unnecessary work. (You could additionally <a href="ForkJoinTask.html#cancel(boolean)">cancel</a> other tasks, but it is usually simpler and more efficient
 to just let them notice that the result is set and if so skip
 further processing.)  Illustrating again with an array using full
 partitioning (again, in practice, leaf tasks will almost always
 process more than one element):

 <pre> <code>
 class Searcher&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final AtomicReference&lt;E&gt; result; final int lo, hi;
   Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result, int lo, int hi) {
     super(p);
     this.array = array; this.result = result; this.lo = lo; this.hi = hi;
   }
   public E getRawResult() { return result.get(); }
   public void compute() { // similar to ForEach version 3
     int l = lo, h = hi;
     while (result.get() == null &amp;&amp; h &gt;= l) {
       if (h - l &gt;= 2) {
         int mid = (l + h) &gt;&gt;&gt; 1;
         addToPendingCount(1);
         new Searcher(this, array, result, mid, h).fork();
         h = mid;
       }
       else {
         E x = array[l];
         if (matches(x) &amp;&amp; result.compareAndSet(null, x))
           quietlyCompleteRoot(); // root task is now joinable
         break;
       }
     }
     tryComplete(); // normally complete whether or not found
   }
   boolean matches(E e) { ... } // return true if found

   public static &lt;E&gt; E search(E[] array) {
       return new Searcher&lt;E&gt;(null, array, new AtomicReference&lt;E&gt;(), 0, array.length).invoke();
   }
 }</code></pre>

 In this example, as well as others in which tasks have no other
 effects except to <code>compareAndSet</code> a common result, the
 trailing unconditional invocation of <code>tryComplete</code> could be
 made conditional (<code>if (result.get() == null) tryComplete();</code>)
 because no further bookkeeping is required to manage completions
 once the root task completes.

 <p><b>Recording subtasks.</b> CountedCompleter tasks that combine
 results of multiple subtasks usually need to access these results
 in method <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>. As illustrated in the following
 class (that performs a simplified form of map-reduce where mappings
 and reductions are all of type <code>E</code>), one way to do this in
 divide and conquer designs is to have each subtask record its
 sibling, so that it can be accessed in method <code>onCompletion</code>.
 This technique applies to reductions in which the order of
 combining left and right results does not matter; ordered
 reductions require explicit left/right designations.  Variants of
 other streamlinings seen in the above examples may also apply.

 <pre> <code>
 class MyMapper&lt;E&gt; { E apply(E v) {  ...  } }
 class MyReducer&lt;E&gt; { E apply(E x, E y) {  ...  } }
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; sibling;
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
   }
   public void compute() {
     if (hi - lo &gt;= 2) {
       int mid = (lo + hi) &gt;&gt;&gt; 1;
       MapReducer&lt;E&gt; left = new MapReducer(this, array, mapper, reducer, lo, mid);
       MapReducer&lt;E&gt; right = new MapReducer(this, array, mapper, reducer, mid, hi);
       left.sibling = right;
       right.sibling = left;
       setPendingCount(1); // only right is pending
       right.fork();
       left.compute();     // directly execute left
     }
     else {
       if (hi &gt; lo)
           result = mapper.apply(array[lo]);
       tryComplete();
     }
   }
   public void onCompletion(CountedCompleter&lt;?&gt; caller) {
     if (caller != this) {
       MapReducer&lt;E&gt; child = (MapReducer&lt;E&gt;)caller;
       MapReducer&lt;E&gt; sib = child.sibling;
       if (sib == null || sib.result == null)
         result = child.result;
       else
         result = reducer.apply(child.result, sib.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length).invoke();
   }
 }</code></pre>

 Here, method <code>onCompletion</code> takes a form common to many
 completion designs that combine results. This callback-style method
 is triggered once per task, in either of the two different contexts
 in which the pending count is, or becomes, zero: (1) by a task
 itself, if its pending count is zero upon invocation of <code>
 tryComplete</code>, or (2) by any of its subtasks when they complete and
 decrement the pending count to zero. The <code>caller</code> argument
 distinguishes cases.  Most often, when the caller is <code>this</code>,
 no action is necessary. Otherwise the caller argument can be used
 (usually via a cast) to supply a value (and/or links to other
 values) to be combined.  Assuming proper use of pending counts, the
 actions inside <code>onCompletion</code> occur (once) upon completion of
 a task and its subtasks. No additional synchronization is required
 within this method to ensure thread safety of accesses to fields of
 this task or other completed tasks.

 <p><b>Completion Traversals.</b> If using <code>onCompletion</code> to
 process completions is inapplicable or inconvenient, you can use
 methods <a href="#firstComplete()"><code>firstComplete()</code></a> and <a href="#nextComplete()"><code>nextComplete()</code></a> to create
 custom traversals.  For example, to define a MapReducer that only
 splits out right-hand tasks in the form of the third ForEach
 example, the completions must cooperatively reduce along
 unexhausted subtask links, which can be done as follows:

 <pre> <code>
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; { // version 2
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; forks, next; // record subtask forks in list
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi, MapReducer&lt;E&gt; next) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
     this.next = next;
   }
   public void compute() {
     int l = lo, h = hi;
     while (h - l &gt;= 2) {
       int mid = (l + h) &gt;&gt;&gt; 1;
       addToPendingCount(1);
       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
       h = mid;
     }
     if (h &gt; l)
       result = mapper.apply(array[l]);
     // process completions by reducing along and advancing subtask links
     for (CountedCompleter&lt;?&gt; c = firstComplete(); c != null; c = c.nextComplete()) {
       for (MapReducer t = (MapReducer)c, s = t.forks; s != null; s = t.forks = s.next)
         t.result = reducer.apply(t.result, s.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length, null).invoke();
   }
 }</code></pre>

 <p><b>Triggers.</b> Some CountedCompleters are themselves never
 forked, but instead serve as bits of plumbing in other designs;
 including those in which the completion of one or more async tasks
 triggers another async task. For example:

 <pre> <code>
 class HeaderBuilder extends CountedCompleter&lt;...&gt; { ... }
 class BodyBuilder extends CountedCompleter&lt;...&gt; { ... }
 class PacketSender extends CountedCompleter&lt;...&gt; {
   PacketSender(...) { super(null, 1); ... } // trigger on second completion
   public void compute() { } // never called
   public void onCompletion(CountedCompleter&lt;?&gt; caller) { sendPacket(); }
 }
 // sample use:
 PacketSender p = new PacketSender();
 new HeaderBuilder(p, ...).fork();
 new BodyBuilder(p, ...).fork();</code></pre></div>
<dl class="notes">
<dt>Since:</dt>
<dd>1.8</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../serialized-form.html#java.util.concurrent.CountedCompleter">Serialized Form</a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested-classes-inherited-from-class-java.util.concurrent.Future">Nested classes/interfaces declared in interface&nbsp;java.util.concurrent.<a href="Future.html" title="interface in java.util.concurrent">Future</a></h2>
<code><a href="Future.State.html" title="enum class in java.util.concurrent">Future.State</a></code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier</div>
<div class="table-header col-second">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>protected </code></div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">CountedCompleter</a>()</code></div>
<div class="col-last even-row-color">
<div class="block">Creates a new CountedCompleter with no completer
 and an initial pending count of zero.</div>
</div>
<div class="col-first odd-row-color"><code>protected </code></div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(java.util.concurrent.CountedCompleter)" class="member-name-link">CountedCompleter</a><wbr>(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer)</code></div>
<div class="col-last odd-row-color">
<div class="block">Creates a new CountedCompleter with the given completer
 and an initial pending count of zero.</div>
</div>
<div class="col-first even-row-color"><code>protected </code></div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(java.util.concurrent.CountedCompleter,int)" class="member-name-link">CountedCompleter</a><wbr>(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer,
 int&nbsp;initialPendingCount)</code></div>
<div class="col-last even-row-color">
<div class="block">Creates a new CountedCompleter with the given completer
 and initial pending count.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#addToPendingCount(int)" class="member-name-link">addToPendingCount</a><wbr>(int&nbsp;delta)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Adds (atomically) the given value to the pending count.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#compareAndSetPendingCount(int,int)" class="member-name-link">compareAndSetPendingCount</a><wbr>(int&nbsp;expected,
 int&nbsp;count)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Sets (atomically) the pending count to the given count only if
 it currently holds the given expected value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#complete(T)" class="member-name-link">complete</a><wbr>(<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;rawResult)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Regardless of pending count, invokes
 <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>, marks this task as
 complete and further triggers <a href="#tryComplete()"><code>tryComplete()</code></a> on this
 task's completer, if one exists.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compute()" class="member-name-link">compute</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">The main computation performed by this task.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#decrementPendingCountUnlessZero()" class="member-name-link">decrementPendingCountUnlessZero</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">If the pending count is nonzero, (atomically) decrements it.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected final boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#exec()" class="member-name-link">exec</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Implements execution conventions for CountedCompleters.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#firstComplete()" class="member-name-link">firstComplete</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">If this task's pending count is zero, returns this task;
 otherwise decrements its pending count and returns <code>null</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getCompleter()" class="member-name-link">getCompleter</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the completer established in this task's constructor,
 or <code>null</code> if none.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getPendingCount()" class="member-name-link">getPendingCount</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the current pending count.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getRawResult()" class="member-name-link">getRawResult</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the result of the computation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getRoot()" class="member-name-link">getRoot</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the root of the current computation; i.e., this
 task if it has no completer, else its completer's root.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#helpComplete(int)" class="member-name-link">helpComplete</a><wbr>(int&nbsp;maxTasks)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">If this task has not completed, attempts to process at most the
 given number of other unprocessed tasks for which this task is
 on the completion path, if any are known to exist.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#nextComplete()" class="member-name-link">nextComplete</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">If this task does not have a completer, invokes <a href="ForkJoinTask.html#quietlyComplete()"><code>ForkJoinTask.quietlyComplete()</code></a> and returns <code>null</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#onCompletion(java.util.concurrent.CountedCompleter)" class="member-name-link">onCompletion</a><wbr>(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Performs an action when method <a href="#tryComplete()"><code>tryComplete()</code></a> is invoked
 and the pending count is zero, or when the unconditional
 method <a href="#complete(T)"><code>complete(T)</code></a> is invoked.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)" class="member-name-link">onExceptionalCompletion</a><wbr>(<a href="../../lang/Throwable.html" title="class in java.lang">Throwable</a>&nbsp;ex,
 <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Performs an action when method <a href="ForkJoinTask.html#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> is invoked or method <a href="#compute()"><code>compute()</code></a> throws an exception, and this task has not already
 otherwise completed normally.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#propagateCompletion()" class="member-name-link">propagateCompletion</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Equivalent to <a href="#tryComplete()"><code>tryComplete()</code></a> but does not invoke <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> along the completion path:
 If the pending count is nonzero, decrements the count;
 otherwise, similarly tries to complete this task's completer, if
 one exists, else marks this task as complete.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#quietlyCompleteRoot()" class="member-name-link">quietlyCompleteRoot</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Equivalent to <code>getRoot().quietlyComplete()</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setPendingCount(int)" class="member-name-link">setPendingCount</a><wbr>(int&nbsp;count)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Sets the pending count to the given value.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setRawResult(T)" class="member-name-link">setRawResult</a><wbr>(<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;t)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">A method that result-bearing CountedCompleters may optionally
 use to help maintain result data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>final void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#tryComplete()" class="member-name-link">tryComplete</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">If the pending count is nonzero, decrements the count;
 otherwise invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>
 and then similarly tries to complete this task's completer,
 if one exists, else marks this task as complete.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.util.concurrent.ForkJoinTask">Methods declared in class&nbsp;java.util.concurrent.<a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a></h3>
<code><a href="ForkJoinTask.html#adapt(java.lang.Runnable)">adapt</a>, <a href="ForkJoinTask.html#adapt(java.lang.Runnable,T)">adapt</a>, <a href="ForkJoinTask.html#adapt(java.util.concurrent.Callable)">adapt</a>, <a href="ForkJoinTask.html#adaptInterruptible(java.util.concurrent.Callable)">adaptInterruptible</a>, <a href="ForkJoinTask.html#cancel(boolean)">cancel</a>, <a href="ForkJoinTask.html#compareAndSetForkJoinTaskTag(short,short)">compareAndSetForkJoinTaskTag</a>, <a href="ForkJoinTask.html#completeExceptionally(java.lang.Throwable)">completeExceptionally</a>, <a href="ForkJoinTask.html#fork()">fork</a>, <a href="ForkJoinTask.html#get()">get</a>, <a href="ForkJoinTask.html#get(long,java.util.concurrent.TimeUnit)">get</a>, <a href="ForkJoinTask.html#getException()">getException</a>, <a href="ForkJoinTask.html#getForkJoinTaskTag()">getForkJoinTaskTag</a>, <a href="ForkJoinTask.html#getPool()">getPool</a>, <a href="ForkJoinTask.html#getQueuedTaskCount()">getQueuedTaskCount</a>, <a href="ForkJoinTask.html#getSurplusQueuedTaskCount()">getSurplusQueuedTaskCount</a>, <a href="ForkJoinTask.html#helpQuiesce()">helpQuiesce</a>, <a href="ForkJoinTask.html#inForkJoinPool()">inForkJoinPool</a>, <a href="ForkJoinTask.html#invoke()">invoke</a>, <a href="ForkJoinTask.html#invokeAll(java.util.Collection)">invokeAll</a>, <a href="ForkJoinTask.html#invokeAll(java.util.concurrent.ForkJoinTask...)">invokeAll</a>, <a href="ForkJoinTask.html#invokeAll(java.util.concurrent.ForkJoinTask,java.util.concurrent.ForkJoinTask)">invokeAll</a>, <a href="ForkJoinTask.html#isCancelled()">isCancelled</a>, <a href="ForkJoinTask.html#isCompletedAbnormally()">isCompletedAbnormally</a>, <a href="ForkJoinTask.html#isCompletedNormally()">isCompletedNormally</a>, <a href="ForkJoinTask.html#isDone()">isDone</a>, <a href="ForkJoinTask.html#join()">join</a>, <a href="ForkJoinTask.html#peekNextLocalTask()">peekNextLocalTask</a>, <a href="ForkJoinTask.html#pollNextLocalTask()">pollNextLocalTask</a>, <a href="ForkJoinTask.html#pollSubmission()">pollSubmission</a>, <a href="ForkJoinTask.html#pollTask()">pollTask</a>, <a href="ForkJoinTask.html#quietlyComplete()">quietlyComplete</a>, <a href="ForkJoinTask.html#quietlyInvoke()">quietlyInvoke</a>, <a href="ForkJoinTask.html#quietlyJoin()">quietlyJoin</a>, <a href="ForkJoinTask.html#quietlyJoin(long,java.util.concurrent.TimeUnit)">quietlyJoin</a>, <a href="ForkJoinTask.html#quietlyJoinUninterruptibly(long,java.util.concurrent.TimeUnit)">quietlyJoinUninterruptibly</a>, <a href="ForkJoinTask.html#reinitialize()">reinitialize</a>, <a href="ForkJoinTask.html#setForkJoinTaskTag(short)">setForkJoinTaskTag</a>, <a href="ForkJoinTask.html#tryUnfork()">tryUnfork</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class&nbsp;java.lang.<a href="../../lang/Object.html" title="class in java.lang">Object</a></h3>
<code><a href="../../lang/Object.html#clone()">clone</a>, <a href="../../lang/Object.html#equals(java.lang.Object)">equals</a>, <a href="../../lang/Object.html#finalize()">finalize</a>, <a href="../../lang/Object.html#getClass()">getClass</a>, <a href="../../lang/Object.html#hashCode()">hashCode</a>, <a href="../../lang/Object.html#notify()">notify</a>, <a href="../../lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../lang/Object.html#toString()">toString</a>, <a href="../../lang/Object.html#wait()">wait</a>, <a href="../../lang/Object.html#wait(long)">wait</a>, <a href="../../lang/Object.html#wait(long,int)">wait</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.util.concurrent.Future">Methods declared in interface&nbsp;java.util.concurrent.<a href="Future.html" title="interface in java.util.concurrent">Future</a></h3>
<code><a href="Future.html#exceptionNow()">exceptionNow</a>, <a href="Future.html#resultNow()">resultNow</a>, <a href="Future.html#state()">state</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;(java.util.concurrent.CountedCompleter,int)">
<h3>CountedCompleter</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="element-name">CountedCompleter</span><wbr><span class="parameters">(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer,
 int&nbsp;initialPendingCount)</span></div>
<div class="block">Creates a new CountedCompleter with the given completer
 and initial pending count.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>completer</code> - this task's completer, or <code>null</code> if none</dd>
<dd><code>initialPendingCount</code> - the initial pending count</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(java.util.concurrent.CountedCompleter)">
<h3>CountedCompleter</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="element-name">CountedCompleter</span><wbr><span class="parameters">(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer)</span></div>
<div class="block">Creates a new CountedCompleter with the given completer
 and an initial pending count of zero.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>completer</code> - this task's completer, or <code>null</code> if none</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>CountedCompleter</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="element-name">CountedCompleter</span>()</div>
<div class="block">Creates a new CountedCompleter with no completer
 and an initial pending count of zero.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="compute()">
<h3>compute</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">compute</span>()</div>
<div class="block">The main computation performed by this task.</div>
</section>
</li>
<li>
<section class="detail" id="onCompletion(java.util.concurrent.CountedCompleter)">
<h3>onCompletion</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">onCompletion</span><wbr><span class="parameters">(<a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</span></div>
<div class="block">Performs an action when method <a href="#tryComplete()"><code>tryComplete()</code></a> is invoked
 and the pending count is zero, or when the unconditional
 method <a href="#complete(T)"><code>complete(T)</code></a> is invoked.  By default, this method
 does nothing. You can distinguish cases by checking the
 identity of the given caller argument. If not equal to <code>
 this</code>, then it is typically a subtask that may contain results
 (and/or links to other results) to combine.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>caller</code> - the task invoking this method (which may
 be this task itself)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter)">
<h3>onExceptionalCompletion</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">onExceptionalCompletion</span><wbr><span class="parameters">(<a href="../../lang/Throwable.html" title="class in java.lang">Throwable</a>&nbsp;ex,
 <a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</span></div>
<div class="block">Performs an action when method <a href="ForkJoinTask.html#completeExceptionally(java.lang.Throwable)"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a> is invoked or method <a href="#compute()"><code>compute()</code></a> throws an exception, and this task has not already
 otherwise completed normally. On entry to this method, this task
 <a href="ForkJoinTask.html#isCompletedAbnormally()"><code>ForkJoinTask.isCompletedAbnormally()</code></a>.  The return value
 of this method controls further propagation: If <code>true</code>
 and this task has a completer that has not completed, then that
 completer is also completed exceptionally, with the same
 exception as this completer.  The default implementation of
 this method does nothing except return <code>true</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>ex</code> - the exception</dd>
<dd><code>caller</code> - the task invoking this method (which may
 be this task itself)</dd>
<dt>Returns:</dt>
<dd><code>true</code> if this exception should be propagated to this
 task's completer, if one exists</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getCompleter()">
<h3>getCompleter</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</span>&nbsp;<span class="element-name">getCompleter</span>()</div>
<div class="block">Returns the completer established in this task's constructor,
 or <code>null</code> if none.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the completer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getPendingCount()">
<h3>getPendingCount</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">getPendingCount</span>()</div>
<div class="block">Returns the current pending count.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the current pending count</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setPendingCount(int)">
<h3>setPendingCount</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">setPendingCount</span><wbr><span class="parameters">(int&nbsp;count)</span></div>
<div class="block">Sets the pending count to the given value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>count</code> - the count</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addToPendingCount(int)">
<h3>addToPendingCount</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">addToPendingCount</span><wbr><span class="parameters">(int&nbsp;delta)</span></div>
<div class="block">Adds (atomically) the given value to the pending count.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>delta</code> - the value to add</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compareAndSetPendingCount(int,int)">
<h3>compareAndSetPendingCount</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">compareAndSetPendingCount</span><wbr><span class="parameters">(int&nbsp;expected,
 int&nbsp;count)</span></div>
<div class="block">Sets (atomically) the pending count to the given count only if
 it currently holds the given expected value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>expected</code> - the expected value</dd>
<dd><code>count</code> - the new value</dd>
<dt>Returns:</dt>
<dd><code>true</code> if successful</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decrementPendingCountUnlessZero()">
<h3>decrementPendingCountUnlessZero</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">decrementPendingCountUnlessZero</span>()</div>
<div class="block">If the pending count is nonzero, (atomically) decrements it.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the initial (undecremented) pending count holding on entry
 to this method</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRoot()">
<h3>getRoot</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</span>&nbsp;<span class="element-name">getRoot</span>()</div>
<div class="block">Returns the root of the current computation; i.e., this
 task if it has no completer, else its completer's root.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the root of the current computation</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="tryComplete()">
<h3>tryComplete</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">tryComplete</span>()</div>
<div class="block">If the pending count is nonzero, decrements the count;
 otherwise invokes <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>
 and then similarly tries to complete this task's completer,
 if one exists, else marks this task as complete.</div>
</section>
</li>
<li>
<section class="detail" id="propagateCompletion()">
<h3>propagateCompletion</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">propagateCompletion</span>()</div>
<div class="block">Equivalent to <a href="#tryComplete()"><code>tryComplete()</code></a> but does not invoke <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> along the completion path:
 If the pending count is nonzero, decrements the count;
 otherwise, similarly tries to complete this task's completer, if
 one exists, else marks this task as complete. This method may be
 useful in cases where <code>onCompletion</code> should not, or need
 not, be invoked for each completer in a computation.</div>
</section>
</li>
<li>
<section class="detail" id="complete(T)">
<h3 id="complete(java.lang.Object)">complete</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">complete</span><wbr><span class="parameters">(<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;rawResult)</span></div>
<div class="block">Regardless of pending count, invokes
 <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a>, marks this task as
 complete and further triggers <a href="#tryComplete()"><code>tryComplete()</code></a> on this
 task's completer, if one exists.  The given rawResult is
 used as an argument to <a href="#setRawResult(T)"><code>setRawResult(T)</code></a> before invoking
 <a href="#onCompletion(java.util.concurrent.CountedCompleter)"><code>onCompletion(CountedCompleter)</code></a> or marking this task
 as complete; its value is meaningful only for classes
 overriding <code>setRawResult</code>.  This method does not modify
 the pending count.

 <p>This method may be useful when forcing completion as soon as
 any one (versus all) of several subtask results are obtained.
 However, in the common (and recommended) case in which <code>
 setRawResult</code> is not overridden, this effect can be obtained
 more simply using <a href="#quietlyCompleteRoot()"><code>quietlyCompleteRoot()</code></a>.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="ForkJoinTask.html#complete(V)">complete</a></code>&nbsp;in class&nbsp;<code><a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code></dd>
<dt>Parameters:</dt>
<dd><code>rawResult</code> - the raw result</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="firstComplete()">
<h3>firstComplete</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</span>&nbsp;<span class="element-name">firstComplete</span>()</div>
<div class="block">If this task's pending count is zero, returns this task;
 otherwise decrements its pending count and returns <code>null</code>.
 This method is designed to be used with <a href="#nextComplete()"><code>nextComplete()</code></a> in
 completion traversal loops.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>this task, if pending count was zero, else <code>null</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nextComplete()">
<h3>nextComplete</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type"><a href="CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</span>&nbsp;<span class="element-name">nextComplete</span>()</div>
<div class="block">If this task does not have a completer, invokes <a href="ForkJoinTask.html#quietlyComplete()"><code>ForkJoinTask.quietlyComplete()</code></a> and returns <code>null</code>.  Or, if
 the completer's pending count is non-zero, decrements that
 pending count and returns <code>null</code>.  Otherwise, returns the
 completer.  This method can be used as part of a completion
 traversal loop for homogeneous task hierarchies:

 <pre> <code>
 for (CountedCompleter&lt;?&gt; c = firstComplete();
      c != null;
      c = c.nextComplete()) {
   // ... process c ...
 }</code></pre></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the completer, or <code>null</code> if none</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="quietlyCompleteRoot()">
<h3>quietlyCompleteRoot</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">quietlyCompleteRoot</span>()</div>
<div class="block">Equivalent to <code>getRoot().quietlyComplete()</code>.</div>
</section>
</li>
<li>
<section class="detail" id="helpComplete(int)">
<h3>helpComplete</h3>
<div class="member-signature"><span class="modifiers">public final</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">helpComplete</span><wbr><span class="parameters">(int&nbsp;maxTasks)</span></div>
<div class="block">If this task has not completed, attempts to process at most the
 given number of other unprocessed tasks for which this task is
 on the completion path, if any are known to exist.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>maxTasks</code> - the maximum number of tasks to process.  If
                 less than or equal to zero, then no tasks are
                 processed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="exec()">
<h3>exec</h3>
<div class="member-signature"><span class="modifiers">protected final</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">exec</span>()</div>
<div class="block">Implements execution conventions for CountedCompleters.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="ForkJoinTask.html#exec()">exec</a></code>&nbsp;in class&nbsp;<code><a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code></dd>
<dt>Returns:</dt>
<dd><code>true</code> if this task is known to have completed normally</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getRawResult()">
<h3>getRawResult</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a></span>&nbsp;<span class="element-name">getRawResult</span>()</div>
<div class="block">Returns the result of the computation.  By default,
 returns <code>null</code>, which is appropriate for <code>Void</code>
 actions, but in other cases should be overridden, almost
 always to return a field or function of a field that
 holds the result upon completion.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="ForkJoinTask.html#getRawResult()">getRawResult</a></code>&nbsp;in class&nbsp;<code><a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code></dd>
<dt>Returns:</dt>
<dd>the result of the computation</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setRawResult(T)">
<h3 id="setRawResult(java.lang.Object)">setRawResult</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">setRawResult</span><wbr><span class="parameters">(<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;t)</span></div>
<div class="block">A method that result-bearing CountedCompleters may optionally
 use to help maintain result data.  By default, does nothing.
 Overrides are not recommended. However, if this method is
 overridden to update existing objects or fields, then it must
 in general be defined to be thread-safe.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="ForkJoinTask.html#setRawResult(V)">setRawResult</a></code>&nbsp;in class&nbsp;<code><a href="ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code></dd>
<dt>Parameters:</dt>
<dd><code>t</code> - the value</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase20&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2022, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java20speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <br><strong>DRAFT 20-internal-2022-07-19-1311514.jlaskey...</strong> <!-- Version 20-internal-2022-07-19-1311514.jlaskey... --></small></p>
</footer>
</div>
</div>
</body>
</html>
