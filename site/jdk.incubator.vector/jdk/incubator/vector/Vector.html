<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (20) -->
<title>Vector (Java SE 20 &amp; JDK 20 [ad-hoc build])</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: jdk.incubator.vector, package: jdk.incubator.vector, class: Vector">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="jdk.incubator.vector.Vector class">
<meta name="keywords" content="species()">
<meta name="keywords" content="elementType()">
<meta name="keywords" content="elementSize()">
<meta name="keywords" content="shape()">
<meta name="keywords" content="length()">
<meta name="keywords" content="bitSize()">
<meta name="keywords" content="byteSize()">
<meta name="keywords" content="lanewise()">
<meta name="keywords" content="add()">
<meta name="keywords" content="sub()">
<meta name="keywords" content="mul()">
<meta name="keywords" content="div()">
<meta name="keywords" content="neg()">
<meta name="keywords" content="abs()">
<meta name="keywords" content="min()">
<meta name="keywords" content="max()">
<meta name="keywords" content="reduceLanesToLong()">
<meta name="keywords" content="test()">
<meta name="keywords" content="eq()">
<meta name="keywords" content="lt()">
<meta name="keywords" content="compare()">
<meta name="keywords" content="blend()">
<meta name="keywords" content="addIndex()">
<meta name="keywords" content="slice()">
<meta name="keywords" content="unslice()">
<meta name="keywords" content="rearrange()">
<meta name="keywords" content="compress()">
<meta name="keywords" content="expand()">
<meta name="keywords" content="selectFrom()">
<meta name="keywords" content="broadcast()">
<meta name="keywords" content="maskAll()">
<meta name="keywords" content="toShuffle()">
<meta name="keywords" content="reinterpretShape()">
<meta name="keywords" content="reinterpretAsBytes()">
<meta name="keywords" content="reinterpretAsShorts()">
<meta name="keywords" content="reinterpretAsInts()">
<meta name="keywords" content="reinterpretAsLongs()">
<meta name="keywords" content="reinterpretAsFloats()">
<meta name="keywords" content="reinterpretAsDoubles()">
<meta name="keywords" content="viewAsIntegralLanes()">
<meta name="keywords" content="viewAsFloatingLanes()">
<meta name="keywords" content="convert()">
<meta name="keywords" content="convertShape()">
<meta name="keywords" content="castShape()">
<meta name="keywords" content="check()">
<meta name="keywords" content="intoMemorySegment()">
<meta name="keywords" content="toArray()">
<meta name="keywords" content="toIntArray()">
<meta name="keywords" content="toLongArray()">
<meta name="keywords" content="toDoubleArray()">
<meta name="keywords" content="toString()">
<meta name="keywords" content="equals()">
<meta name="keywords" content="hashCode()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.0.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header"><div style="padding: 6px; text-align: center; font-size: 80%; font-family: DejaVu Sans, Arial, Helvetica, sans-serif; font-weight: normal;">This specification is not final and is subject to change. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java20speclicense.html">license terms</a>.</div>
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 9px;"><strong>Java SE 20 &amp; JDK 20</strong> <br><strong>DRAFT 20-internal-2022-07-19-1311514.jlaskey...</strong></div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Vector.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">jdk.incubator.vector</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">jdk.incubator.vector</a></div>
<h1 title="Class Vector" class="title">Class Vector&lt;E&gt;</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">java.lang.Object</a>
<div class="inheritance">jdk.internal.vm.vector.VectorSupport.VectorPayload
<div class="inheritance">jdk.internal.vm.vector.VectorSupport.Vector&lt;E&gt;
<div class="inheritance">jdk.incubator.vector.Vector&lt;E&gt;</div>
</div>
</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>E</code> - the boxed version of <code>ETYPE</code>,
           the element type of a vector</dd>
</dl>
<dl class="notes">
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="ByteVector.html" title="class in jdk.incubator.vector">ByteVector</a></code>, <code><a href="DoubleVector.html" title="class in jdk.incubator.vector">DoubleVector</a></code>, <code><a href="FloatVector.html" title="class in jdk.incubator.vector">FloatVector</a></code>, <code><a href="IntVector.html" title="class in jdk.incubator.vector">IntVector</a></code>, <code><a href="LongVector.html" title="class in jdk.incubator.vector">LongVector</a></code>, <code><a href="ShortVector.html" title="class in jdk.incubator.vector">ShortVector</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public abstract class </span><span class="element-name type-name-label">Vector&lt;E&gt;</span>
<span class="extends-implements">extends jdk.internal.vm.vector.VectorSupport.Vector&lt;E&gt;</span></div>
<div class="preview-block" id="preview-jdk.incubator.vector.Vector"><span class="preview-label"><code>Vector</code> relies on preview features of the Java platform:</span>
<ul class="preview-comment">
<li><code>Vector</code> refers to one or more preview APIs:  <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>.</li>
</ul>
<div class="preview-comment">Programs can only use <code>Vector</code> when preview features are enabled.</div>
<div class="preview-comment">Preview features may be removed in a future release, or upgraded to permanent features of the Java platform.</div>
</div>
<div class="block">A

 <!-- The following paragraphs are shared verbatim
   -- between Vector.java and package-info.java -->
 sequence of a fixed number of <em>lanes</em>,
 all of some fixed
 <a href="#elementType()"><em>element type</em></a>
 such as <code>byte</code>, <code>long</code>, or <code>float</code>.
 Each lane contains an independent value of the element type.
 Operations on vectors are typically
 <a href="Vector.html#lane-wise"><em>lane-wise</em></a>,
 distributing some scalar operator (such as
 <a href="#add(jdk.incubator.vector.Vector)">addition</a>)
 across the lanes of the participating vectors,
 usually generating a vector result whose lanes contain the various
 scalar results.  When run on a supporting platform, lane-wise
 operations can be executed in parallel by the hardware.  This style
 of parallelism is called <em>Single Instruction Multiple Data</em>
 (SIMD) parallelism.

 <p> In the SIMD style of programming, most of the operations within
 a vector lane are unconditional, but the effect of conditional
 execution may be achieved using
 <a href="Vector.html#masking"><em>masked operations</em></a>
 such as <a href="#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>blend()</code></a>,
 under the control of an associated <a href="VectorMask.html" title="class in jdk.incubator.vector"><code>VectorMask</code></a>.
 Data motion other than strictly lane-wise flow is achieved using
 <a href="Vector.html#cross-lane"><em>cross-lane</em></a>
 operations, often under the control of an associated
 <a href="VectorShuffle.html" title="class in jdk.incubator.vector"><code>VectorShuffle</code></a>.
 Lane data and/or whole vectors can be reformatted using various
 kinds of lane-wise
 <a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)">conversions</a>,
 and byte-wise reformatting
 <a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)">reinterpretations</a>,
 often under the control of a reflective <a href="VectorSpecies.html" title="interface in jdk.incubator.vector"><code>VectorSpecies</code></a>
 object which selects an alternative vector format different
 from that of the input vector.

 <p> <code>Vector&lt;E&gt;</code> declares a set of vector operations (methods)
 that are common to all element types.  These common operations
 include generic access to lane values, data selection and movement,
 reformatting, and certain arithmetic and logical operations (such as addition
 or comparison) that are common to all primitive types.

 <p> <a href="Vector.html#subtypes">Public subtypes of <code>Vector</code></a>
 correspond to specific
 element types.  These declare further operations that are specific
 to that element type, including unboxed access to lane values,
 bitwise operations on values of integral element types, or
 transcendental operations on values of floating point element
 types.

 <p> Some lane-wise operations, such as the <code>add</code> operator, are defined as
 a full-service named operation, where a corresponding method on <code>Vector</code>
 comes in masked and unmasked overloadings, and (in subclasses) also comes in
 covariant overrides (returning the subclass) and additional scalar-broadcast
 overloadings (both masked and unmasked).

 Other lane-wise operations, such as the <code>min</code> operator, are defined as a
 partially serviced (not a full-service) named operation, where a corresponding
 method on <code>Vector</code> and/or a subclass provide some but all possible
 overloadings and overrides (commonly the unmasked variant with scalar-broadcast
 overloadings).

 Finally, all lane-wise operations (those named as previously described,
 or otherwise unnamed method-wise) have a corresponding
 <a href="VectorOperators.Operator.html" title="interface in jdk.incubator.vector"><code>operator token</code></a>
 declared as a static constant on <a href="VectorOperators.html" title="class in jdk.incubator.vector"><code>VectorOperators</code></a>.
 Each operator token defines a symbolic Java expression for the operation,
 such as <code>a + b</code> for the
 <a href="VectorOperators.html#ADD"><code>ADD</code></a> operator token.
 General lane-wise operation-token accepting methods, such as for a
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)">unary lane-wise</a>
 operation, are provided on <code>Vector</code> and come in the same variants as
 a full-service named operation.

 <p>This package contains a public subtype of <a href="Vector.html" title="class in jdk.incubator.vector"><code>Vector</code></a>
 corresponding to each supported element type:
 <a href="ByteVector.html" title="class in jdk.incubator.vector"><code>ByteVector</code></a>, <a href="ShortVector.html" title="class in jdk.incubator.vector"><code>ShortVector</code></a>,
 <a href="IntVector.html" title="class in jdk.incubator.vector"><code>IntVector</code></a>, <a href="LongVector.html" title="class in jdk.incubator.vector"><code>LongVector</code></a>,
 <a href="FloatVector.html" title="class in jdk.incubator.vector"><code>FloatVector</code></a>, and <a href="DoubleVector.html" title="class in jdk.incubator.vector"><code>DoubleVector</code></a>.

 <!-- The preceding paragraphs are shared verbatim
   -- between Vector.java and package-info.java -->

 <p><a id="ETYPE"></a> The <a href="#elementType()">element type</a> of a vector,
 referred to as <code>ETYPE</code>, is one of the primitive types
 <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>
 float</code>, or <code>double</code>.

 <p> The type <code>E</code> in <code>Vector&lt;E&gt;</code> is the <em>boxed</em> version
 of <code>ETYPE</code>. For example, in the type <code>Vector&lt;Integer&gt;</code>, the <code>E</code>
 parameter is <code>Integer</code> and the <code>ETYPE</code> is <code>int</code>.  In such a
 vector, each lane carries a primitive <code>int</code> value.  This pattern continues
 for the other primitive types as well. (See also sections <a href="https://docs.oracle.com/javase/specs/jls/se20/html/jls-5.html#jls-5.1.7">5.1.7</a> and
 <a href="https://docs.oracle.com/javase/specs/jls/se20/html/jls-5.html#jls-5.1.8">5.1.8</a> of the <cite>The Java Language Specification</cite>.)

 <p><a id="VLENGTH"></a> The <a href="#length()">length</a> of a vector
 is the lane count, the number of lanes it contains.

 This number is also called <code>VLENGTH</code> when the context makes
 clear which vector it belongs to.  Each vector has its own fixed
 <code>VLENGTH</code> but different instances of vectors may have
 different lengths.  <code>VLENGTH</code> is an important number, because
 it estimates the SIMD performance gain of a single vector operation
 as compared to scalar execution of the <code>VLENGTH</code> scalar
 operators which underly the vector operation.

 <h2><a id="species"></a>Shapes and species</h2>

 The information capacity of a vector is determined by its
 <a href="#shape()"><em>vector shape</em></a>, also called its
 <code>VSHAPE</code>.  Each possible <code>VSHAPE</code> is represented by
 a member of the <a href="VectorShape.html" title="enum class in jdk.incubator.vector"><code>VectorShape</code></a> enumeration, and represents
 an implementation format shared in common by all vectors of
 that shape.  Thus, the <a href="#bitSize()">size in bits</a> of
 of a vector is determined by appealing to its vector shape.

 <p> Some Java platforms give special support to only one shape,
 while others support several.  A typical platform is not likely
 to support all the shapes described by this API.  For this reason,
 most vector operations work on a single input shape and
 produce the same shape on output.  Operations which change
 shape are clearly documented as such <em>shape-changing</em>,
 while the majority of operations are <em>shape-invariant</em>,
 to avoid disadvantaging platforms which support only one shape.
 There are queries to discover, for the current Java platform,
 the <a href="VectorShape.html#preferredShape()">preferred shape</a>
 for general SIMD computation, or the
 largest
 available shape for any given lane type.  To be portable,
 code using this API should start by querying a supported
 shape, and then process all data with shape-invariant
 operations, within the selected shape.

 <p> Each unique combination of element type and vector shape
 determines a unique
 <a href="#species()"><em>vector species</em></a>.
 A vector species is represented by a fixed instance of
 <a href="VectorSpecies.html" title="interface in jdk.incubator.vector"><code>VectorSpecies&lt;E&gt;</code></a>
 shared in common by all vectors of the same shape and
 <code>ETYPE</code>.

 <p> Unless otherwise documented, lane-wise vector operations
 require that all vector inputs have exactly the same <code>VSHAPE</code>
 and <code>VLENGTH</code>, which is to say that they must have exactly
 the same species.  This allows corresponding lanes to be paired
 unambiguously.  The <a href="#check(jdk.incubator.vector.VectorSpecies)"><code>check()</code></a> method
 provides an easy way to perform this check explicitly.

 <p> Vector shape, <code>VLENGTH</code>, and <code>ETYPE</code> are all
 mutually constrained, so that <code>VLENGTH</code> times the
 <a href="#elementSize()">bit-size of each lane</a>
 must always match the bit-size of the vector's shape.

 Thus, <a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)">reinterpreting</a> a
 vector may double its length if and only if it either halves the lane size,
 or else changes the shape.  Likewise, reinterpreting a vector may double the
 lane size if and only if it either halves the length, or else changes the
 shape of the vector.

 <h2><a id="subtypes"></a>Vector subtypes</h2>

 Vector declares a set of vector operations (methods) that are common to all
 element types (such as addition).  Sub-classes of Vector with a concrete
 element type declare further operations that are specific to that
 element type (such as access to element values in lanes, logical operations
 on values of integral elements types, or transcendental operations on values
 of floating point element types).
 There are six abstract sub-classes of Vector corresponding to the supported set
 of element types, <a href="ByteVector.html" title="class in jdk.incubator.vector"><code>ByteVector</code></a>, <a href="ShortVector.html" title="class in jdk.incubator.vector"><code>ShortVector</code></a>,
 <a href="IntVector.html" title="class in jdk.incubator.vector"><code>IntVector</code></a>, <a href="LongVector.html" title="class in jdk.incubator.vector"><code>LongVector</code></a>, <a href="FloatVector.html" title="class in jdk.incubator.vector"><code>FloatVector</code></a>, and
 <a href="DoubleVector.html" title="class in jdk.incubator.vector"><code>DoubleVector</code></a>. Along with type-specific operations these classes
 support creation of vector values (instances of Vector).
 They expose static constants corresponding to the supported species,
 and static methods on these types generally take a species as a parameter.
 For example,
 <a href="FloatVector.html#fromArray(jdk.incubator.vector.VectorSpecies,float%5B%5D,int)"><code>FloatVector.fromArray</code></a>
 creates and returns a float vector of the specified species, with elements
 loaded from the specified float array.
 It is recommended that Species instances be held in <code>static final</code>
 fields for optimal creation and usage of Vector values by the runtime compiler.

 <p> As an example of static constants defined by the typed vector classes,
 constant <a href="FloatVector.html#SPECIES_256"><code>FloatVector.SPECIES_256</code></a>
 is the unique species whose lanes are <code>float</code>s and whose
 vector size is 256 bits.  Again, the constant
 <a href="FloatVector.html#SPECIES_PREFERRED"><code>FloatVector.SPECIES_PREFERRED</code></a> is the species which
 best supports processing of <code>float</code> vector lanes on
 the currently running Java platform.

 <p> As another example, a broadcast scalar value of
 <code>(double)0.5</code> can be obtained by calling
 <a href="DoubleVector.html#broadcast(jdk.incubator.vector.VectorSpecies,double)"><code>DoubleVector.broadcast(dsp, 0.5)</code></a>, but the argument <code>dsp</code> is
 required to select the species (and hence the shape and length) of
 the resulting vector.

 <h2><a id="lane-wise"></a>Lane-wise operations</h2>

 We use the term <em>lanes</em> when defining operations on
 vectors. The number of lanes in a vector is the number of scalar
 elements it holds. For example, a vector of type <code>float</code> and
 shape <code>S_256_BIT</code> has eight lanes, since <code>32*8=256</code>.

 <p> Most operations on vectors are lane-wise, which means the operation
 is composed of an underlying scalar operator, which is repeated for
 each distinct lane of the input vector.  If there are additional
 vector arguments of the same type, their lanes are aligned with the
 lanes of the first input vector.  (They must all have a common
 <code>VLENGTH</code>.)  For most lane-wise operations, the output resulting
 from a lane-wise operation will have a <code>VLENGTH</code> which is equal to
 the <code>VLENGTH</code> of the input(s) to the operation.  Thus, such lane-wise
 operations are <em>length-invariant</em>, in their basic definitions.

 <p> The principle of length-invariance is combined with another
 basic principle, that most length-invariant lane-wise operations are also
 <em>shape-invariant</em>, meaning that the inputs and the output of
 a lane-wise operation will have a common <code>VSHAPE</code>.  When the
 principles conflict, because a logical result (with an invariant
 <code>VLENGTH</code>), does not fit into the invariant <code>VSHAPE</code>,
 the resulting expansions and contractions are handled explicitly
 with
 <a href="Vector.html#expansion">special conventions</a>.

 <p> Vector operations can be grouped into various categories and
 their behavior can be generally specified in terms of underlying
 scalar operators.  In the examples below, <code>ETYPE</code> is the
 element type of the operation (such as <code>int.class</code>) and
 <code>EVector</code> is the corresponding concrete vector type (such as
 <code>IntVector.class</code>).

 <ul>
 <li>
 A <em>lane-wise unary</em> operation, such as
 <code>w = v0.</code><a href="#neg()"><code>neg</code></a><code>()</code>,
 takes one input vector,
 distributing a unary scalar operator across the lanes,
 and produces a result vector of the same type and shape.

 For each lane of the input vector <code>a</code>,
 the underlying scalar operator is applied to the lane value.
 The result is placed into the vector result in the same lane.
 The following pseudocode illustrates the behavior of this operation
 category:

 <pre><code>
 ETYPE scalar_unary_op(ETYPE s);
 EVector a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 ETYPE[] ar = new ETYPE[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     ar[i] = scalar_unary_op(a.lane(i));
 }
 EVector r = EVector.fromArray(species, ar, 0);
 </code></pre>

 <li>
 A <em>lane-wise binary</em> operation, such as
 <code>w = v0.</code><a href="#add(jdk.incubator.vector.Vector)"><code>add</code></a><code>(v1)</code>,
 takes two input vectors,
 distributing a binary scalar operator across the lanes,
 and produces a result vector of the same type and shape.

 For each lane of the two input vectors <code>a</code> and <code>b</code>,
 the underlying scalar operator is applied to the lane values.
 The result is placed into the vector result in the same lane.
 The following pseudocode illustrates the behavior of this operation
 category:

 <pre><code>
 ETYPE scalar_binary_op(ETYPE s, ETYPE t);
 EVector a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 EVector b = ...;
 b.check(species);  // must have same species
 ETYPE[] ar = new ETYPE[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     ar[i] = scalar_binary_op(a.lane(i), b.lane(i));
 }
 EVector r = EVector.fromArray(species, ar, 0);
 </code></pre>
 </li>

 <li>
 Generalizing from unary and binary operations,
 a <em>lane-wise n-ary</em> operation takes <code>N</code> input vectors <code>v[j]</code>,
 distributing an n-ary scalar operator across the lanes,
 and produces a result vector of the same type and shape.
 Except for a few ternary operations, such as
 <code>w = v0.</code><a href="FloatVector.html#fma(jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)"><code>fma</code></a><code>(v1,v2)</code>,
 this API has no support for
 lane-wise n-ary operations.

 For each lane of all of the input vectors <code>v[j]</code>,
 the underlying scalar operator is applied to the lane values.
 The result is placed into the vector result in the same lane.
 The following pseudocode illustrates the behavior of this operation
 category:

 <pre><code>
 ETYPE scalar_nary_op(ETYPE... args);
 EVector[] v = ...;
 int N = v.length;
 VectorSpecies&lt;E&gt; species = v[0].species();
 for (EVector arg : v) {
     arg.check(species);  // all must have same species
 }
 ETYPE[] ar = new ETYPE[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     ETYPE[] args = new ETYPE[N];
     for (int j = 0; j &lt; N; j++) {
         args[j] = v[j].lane(i);
     }
     ar[i] = scalar_nary_op(args);
 }
 EVector r = EVector.fromArray(species, ar, 0);
 </code></pre>
 </li>

 <li>
 A <em>lane-wise conversion</em> operation, such as
 <code>w0 = v0.</code><a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>convert</code></a><code>(VectorOperators.I2D, 0)</code>,
 takes one input vector,
 distributing a unary scalar conversion operator across the lanes,
 and produces a logical result of the converted values.  The logical
 result (or at least a part of it) is presented in a vector of the
 same shape as the input vector.

 <p> Unlike other lane-wise operations, conversions can change lane
 type, from the input (domain) type to the output (range) type.  The
 lane size may change along with the type.  In order to manage the
 size changes, lane-wise conversion methods can product <em>partial
 results</em>, under the control of a <code>part</code> parameter, which
 is <a href="Vector.html#expansion">explained elsewhere</a>.
 (Following the example above, the second group of converted lane
 values could be obtained as
 <code>w1 = v0.convert(VectorOperators.I2D, 1)</code>.)

 <p> The following pseudocode illustrates the behavior of this
 operation category in the specific example of a conversion from
 <code>int</code> to <code>double</code>, retaining either lower or upper
 lanes (depending on <code>part</code>) to maintain shape-invariance:

 <pre><code>
 IntVector a = ...;
 int VLENGTH = a.length();
 int part = ...;  // 0 or 1
 VectorShape VSHAPE = a.shape();
 double[] arlogical = new double[VLENGTH];
 for (int i = 0; i &lt; limit; i++) {
     int e = a.lane(i);
     arlogical[i] = (double) e;
 }
 VectorSpecies&lt;Double&gt; rs = VSHAPE.withLanes(double.class);
 int M = Double.BITS / Integer.BITS;  // expansion factor
 int offset = part * (VLENGTH / M);
 DoubleVector r = DoubleVector.fromArray(rs, arlogical, offset);
 assert r.length() == VLENGTH / M;
 </code></pre>
 </li>

 <li>
 A <em>cross-lane reduction</em> operation, such as
 <code>e = v0.</code><a href="IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)"><code>reduceLanes</code></a><code>(VectorOperators.ADD)</code>,
 operates on all
 the lane elements of an input vector.
 An accumulation function is applied to all the
 lane elements to produce a scalar result.
 If the reduction operation is associative then the result may be accumulated
 by operating on the lane elements in any order using a specified associative
 scalar binary operation and identity value.  Otherwise, the reduction
 operation specifies the order of accumulation.
 The following pseudocode illustrates the behavior of this operation category
 if it is associative:
 <pre><code>
 ETYPE assoc_scalar_binary_op(ETYPE s, ETYPE t);
 EVector a = ...;
 ETYPE r = &lt;identity value&gt;;
 for (int i = 0; i &lt; a.length(); i++) {
     r = assoc_scalar_binary_op(r, a.lane(i));
 }
 </code></pre>
 </li>

 <li>
 A <em>cross-lane movement</em> operation, such as
 <code>w = v0.</code><a href="#rearrange(jdk.incubator.vector.VectorShuffle)"><code>rearrange</code></a><code>(shuffle)</code>
 operates on all
 the lane elements of an input vector and moves them
 in a data-dependent manner into <em>different lanes</em>
 in an output vector.
 The movement is steered by an auxiliary datum, such as
 a <a href="VectorShuffle.html" title="class in jdk.incubator.vector"><code>VectorShuffle</code></a> or a scalar index defining the
 origin of the movement.
 The following pseudocode illustrates the behavior of this
 operation category, in the case of a shuffle:
 <pre><code>
 EVector a = ...;
 Shuffle&lt;E&gt; s = ...;
 ETYPE[] ar = new ETYPE[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     int source = s.laneSource(i);
     ar[i] = a.lane(source);
 }
 EVector r = EVector.fromArray(a.species(), ar, 0);
 </code></pre>
 </li>

 <li>
 A <em>masked operation</em> is one which is a variation on one of the
 previous operations (either lane-wise or cross-lane), where
 the operation takes an extra trailing <a href="VectorMask.html" title="class in jdk.incubator.vector"><code>VectorMask</code></a> argument.
 In lanes the mask is set, the operation behaves as if the mask
 argument were absent, but in lanes where the mask is unset, the
 underlying scalar operation is suppressed.
 Masked operations are explained in
 <a href="Vector.html#masking">greater detail elsewhere</a>.
 </li>

 <li>
 A very special case of a masked lane-wise binary operation is a
 <a href="#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">blend</a>, which operates
 lane-wise on two input vectors <code>a</code> and <code>b</code>, selecting lane
 values from one input or the other depending on a mask <code>m</code>.
 In lanes where <code>m</code> is set, the corresponding value from
 <code>b</code> is selected into the result; otherwise the value from
 <code>a</code> is selected.  Thus, a blend acts as a vectorized version
 of Java's ternary selection expression <code>m?b:a</code>:
 <pre><code>
 ETYPE[] ar = new ETYPE[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     boolean isSet = m.laneIsSet(i);
     ar[i] = isSet ? b.lane(i) : a.lane(i);
 }
 EVector r = EVector.fromArray(species, ar, 0);
 </code></pre>
 </li>

 <li>
 A <em>lane-wise binary test</em> operation, such as
 <code>m = v0.</code><a href="#lt(jdk.incubator.vector.Vector)"><code>lt</code></a><code>(v1)</code>,
 takes two input vectors,
 distributing a binary scalar comparison across the lanes,
 and produces, not a vector of booleans, but rather a
 <a href="VectorMask.html" title="class in jdk.incubator.vector">vector mask</a>.

 For each lane of the two input vectors <code>a</code> and <code>b</code>,
 the underlying scalar comparison operator is applied to the lane values.
 The resulting boolean is placed into the vector mask result in the same lane.
 The following pseudocode illustrates the behavior of this operation
 category:
 <pre><code>
 boolean scalar_binary_test_op(ETYPE s, ETYPE t);
 EVector a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 EVector b = ...;
 b.check(species);  // must have same species
 boolean[] mr = new boolean[a.length()];
 for (int i = 0; i &lt; mr.length; i++) {
     mr[i] = scalar_binary_test_op(a.lane(i), b.lane(i));
 }
 VectorMask&lt;E&gt; m = VectorMask.fromArray(species, mr, 0);
 </code></pre>
 </li>

 <li>
 Similarly to a binary comparison, a <em>lane-wise unary test</em>
 operation, such as
 <code>m = v0.</code><a href="#test(jdk.incubator.vector.VectorOperators.Test)"><code>test</code></a><code>(IS_FINITE)</code>,
 takes one input vector, distributing a scalar predicate
 (a test function) across the lanes, and produces a
 <a href="VectorMask.html" title="class in jdk.incubator.vector">vector mask</a>.
 </li>

 </ul>

 <p>
 If a vector operation does not belong to one of the above categories then
 the method documentation explicitly specifies how it processes the lanes of
 input vectors, and where appropriate illustrates the behavior using
 pseudocode.

 <p>
 Most lane-wise binary and comparison operations offer convenience
 overloadings which accept a scalar as the second input, in place of a
 vector.  In this case the scalar value is promoted to a vector by
 <a href="#broadcast(long)">broadcasting it</a>
 into the same lane structure as the first input.

 For example, to multiply all lanes of a <code>double</code> vector by
 a scalar value <code>1.1</code>, the expression <code>v.mul(1.1)</code> is
 easier to work with than an equivalent expression with an explicit
 broadcast operation, such as <code>v.mul(v.broadcast(1.1))</code>
 or <code>v.mul(DoubleVector.broadcast(v.species(), 1.1))</code>.

 Unless otherwise specified the scalar variant always behaves as if
 each scalar value is first transformed to a vector of the same
 species as the first vector input, using the appropriate
 <code>broadcast</code> operation.

 <h2><a id="masking"></a>Masked operations</h2>

 <p> Many vector operations accept an optional
 <a href="VectorMask.html" title="class in jdk.incubator.vector"><code>mask</code></a> argument, selecting which lanes participate
 in the underlying scalar operator.  If present, the mask argument
 appears at the end of the method argument list.

 <p> Each lane of the mask argument is a boolean which is either in
 the <em>set</em> or <em>unset</em> state.  For lanes where the mask
 argument is unset, the underlying scalar operator is suppressed.
 In this way, masks allow vector operations to emulate scalar
 control flow operations, without losing SIMD parallelism, except
 where the mask lane is unset.

 <p> An operation suppressed by a mask will never cause an exception
 or side effect of any sort, even if the underlying scalar operator
 can potentially do so.  For example, an unset lane that seems to
 access an out of bounds array element or divide an integral value
 by zero will simply be ignored.  Values in suppressed lanes never
 participate or appear in the result of the overall operation.

 <p> Result lanes corresponding to a suppressed operation will be
 filled with a default value which depends on the specific
 operation, as follows:

 <ul>

 <li>If the masked operation is a unary, binary, or n-ary arithmetic or
 logical operation, suppressed lanes are filled from the first
 vector operand (i.e., the vector receiving the method call), as if
 by a <a href="#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">blend</a>.</li>

 <li>If the masked operation is a memory load or a <code>slice()</code> from
 another vector, suppressed lanes are not loaded, and are filled
 with the default value for the <code>ETYPE</code>, which in every case
 consists of all zero bits.  An unset lane can never cause an
 exception, even if the hypothetical corresponding memory location
 does not exist (because it is out of an array's index range).</li>

 <li>If the operation is a cross-lane operation with an operand
 which supplies lane indexes (of type <code>VectorShuffle</code> or
 <code>Vector</code>, suppressed lanes are not computed, and are filled
 with the zero default value.  Normally, invalid lane indexes elicit
 an <code>IndexOutOfBoundsException</code>, but if a lane is unset, the
 zero value is quietly substituted, regardless of the index.  This
 rule is similar to the previous rule, for masked memory loads.</li>

 <li>If the masked operation is a memory store or an <code>unslice()</code> into
 another vector, suppressed lanes are not stored, and the
 corresponding memory or vector locations (if any) are unchanged.

 <p> (Note: Memory effects such as race conditions never occur for
 suppressed lanes.  That is, implementations will not secretly
 re-write the existing value for unset lanes.  In the Java Memory
 Model, reassigning a memory variable to its current value is not a
 no-op; it may quietly undo a racing store from another
 thread.)</p>
 </li>

 <li>If the masked operation is a reduction, suppressed lanes are ignored
 in the reduction.  If all lanes are suppressed, a suitable neutral
 value is returned, depending on the specific reduction operation,
 and documented by the masked variant of that method.  (This means
 that users can obtain the neutral value programmatically by
 executing the reduction on a dummy vector with an all-unset mask.)

 <li>If the masked operation is a comparison operation, suppressed output
 lanes in the resulting mask are themselves unset, as if the
 suppressed comparison operation returned <code>false</code> regardless
 of the suppressed input values.  In effect, it is as if the
 comparison operation were performed unmasked, and then the
 result intersected with the controlling mask.</li>

 <li>In other cases, such as masked
 <a href="Vector.html#cross-lane"><em>cross-lane movements</em></a>,
 the specific effects of masking are documented by the masked
 variant of the method.

 </ul>

 <p> As an example, a masked binary operation on two input vectors
 <code>a</code> and <code>b</code> suppresses the binary operation for lanes
 where the mask is unset, and retains the original lane value from
 <code>a</code>.  The following pseudocode illustrates this behavior:
 <pre><code>
 ETYPE scalar_binary_op(ETYPE s, ETYPE t);
 EVector a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 EVector b = ...;
 b.check(species);  // must have same species
 VectorMask&lt;E&gt; m = ...;
 m.check(species);  // must have same species
 boolean[] ar = new boolean[a.length()];
 for (int i = 0; i &lt; ar.length; i++) {
     if (m.laneIsSet(i)) {
         ar[i] = scalar_binary_op(a.lane(i), b.lane(i));
     } else {
         ar[i] = a.lane(i);  // from first input
     }
 }
 EVector r = EVector.fromArray(species, ar, 0);
 </code></pre>

 <h2><a id="lane-order"></a>Lane order and byte order</h2>

 The number of lane values stored in a given vector is referred to
 as its <a href="#length()">vector length</a> or <code>VLENGTH</code>.

 It is useful to consider vector lanes as ordered
 <em>sequentially</em> from first to last, with the first lane
 numbered <code>0</code>, the next lane numbered <code>1</code>, and so on to
 the last lane numbered <code>VLENGTH-1</code>.  This is a temporal
 order, where lower-numbered lanes are considered earlier than
 higher-numbered (later) lanes.  This API uses these terms
 in preference to spatial terms such as "left", "right", "high",
 and "low".

 <p> Temporal terminology works well for vectors because they
 (usually) represent small fixed-sized segments in a long sequence
 of workload elements, where the workload is conceptually traversed
 in time order from beginning to end.  (This is a mental model: it
 does not exclude multicore divide-and-conquer techniques.)  Thus,
 when a scalar loop is transformed into a vector loop, adjacent
 scalar items (one earlier, one later) in the workload end up as
 adjacent lanes in a single vector (again, one earlier, one later).
 At a vector boundary, the last lane item in the earlier vector is
 adjacent to (and just before) the first lane item in the
 immediately following vector.

 <p> Vectors are also sometimes thought of in spatial terms, where
 the first lane is placed at an edge of some virtual paper, and
 subsequent lanes are presented in order next to it.  When using
 spatial terms, all directions are equally plausible: Some vector
 notations present lanes from left to right, and others from right
 to left; still others present from top to bottom or vice versa.
 Using the language of time (before, after, first, last) instead of
 space (left, right, high, low) is often more likely to avoid
 misunderstandings.

 <p> As second reason to prefer temporal to spatial language about
 vector lanes is the fact that the terms "left", "right", "high" and
 "low" are widely used to describe the relations between bits in
 scalar values.  The leftmost or highest bit in a given type is
 likely to be a sign bit, while the rightmost or lowest bit is
 likely to be the arithmetically least significant, and so on.
 Applying these terms to vector lanes risks confusion, however,
 because it is relatively rare to find algorithms where, given two
 adjacent vector lanes, one lane is somehow more arithmetically
 significant than its neighbor, and even in those cases, there is no
 general way to know which neighbor is the more significant.

 <p> Putting the terms together, we view the information structure
 of a vector as a temporal sequence of lanes ("first", "next",
 "earlier", "later", "last", etc.)  of bit-strings which are
 internally ordered spatially (either "low" to "high" or "right" to
 "left").  The primitive values in the lanes are decoded from these
 bit-strings, in the usual way.  Most vector operations, like most
 Java scalar operators, treat primitive values as atomic values, but
 some operations reveal the internal bit-string structure.

 <p> When a vector is loaded from or stored into memory, the order
 of vector lanes is <em>always consistent </em> with the inherent
 ordering of the memory container.  This is true whether or not
 individual lane elements are subject to "byte swapping" due to
 details of byte order.  Thus, while the scalar lane elements of
 vector might be "byte swapped", the lanes themselves are never
 reordered, except by an explicit method call that performs
 cross-lane reordering.

 <p> When vector lane values are stored to Java variables of the
 same type, byte swapping is performed if and only if the
 implementation of the vector hardware requires such swapping.  It
 is therefore unconditional and invisible.

 <p> As a useful fiction, this API presents a consistent illusion
 that vector lane bytes are composed into larger lane scalars in
 <em>little endian order</em>.  This means that storing a vector
 into a Java byte array will reveal the successive bytes of the
 vector lane values in little-endian order on all platforms,
 regardless of native memory order, and also regardless of byte
 order (if any) within vector unit registers.

 <p> This hypothetical little-endian ordering also appears when a
 <a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)">reinterpretation cast</a> is
 applied in such a way that lane boundaries are discarded and
 redrawn differently, while maintaining vector bits unchanged.  In
 such an operation, two adjacent lanes will contribute bytes to a
 single new lane (or vice versa), and the sequential order of the
 two lanes will determine the arithmetic order of the bytes in the
 single lane.  In this case, the little-endian convention provides
 portable results, so that on all platforms earlier lanes tend to
 contribute lower (rightward) bits, and later lanes tend to
 contribute higher (leftward) bits.  The <a href="#reinterpretAsBytes()">reinterpretation casts</a> between <a href="ByteVector.html" title="class in jdk.incubator.vector"><code>ByteVector</code></a>s and the
 other non-byte vectors use this convention to clarify their
 portable semantics.

 <p> The little-endian fiction for relating lane order to per-lane
 byte order is slightly preferable to an equivalent big-endian
 fiction, because some related formulas are much simpler,
 specifically those which renumber bytes after lane structure
 changes.  The earliest byte is invariantly earliest across all lane
 structure changes, but only if little-endian convention are used.
 The root cause of this is that bytes in scalars are numbered from
 the least significant (rightmost) to the most significant
 (leftmost), and almost never vice-versa.  If we habitually numbered
 sign bits as zero (as on some computers) then this API would reach
 for big-endian fictions to create unified addressing of vector
 bytes.

 <h2><a id="memory"></a>Memory operations</h2>

 As was already mentioned, vectors can be loaded from memory and
 stored back.  An optional mask can control which individual memory
 locations are read from or written to.  The shape of a vector
 determines how much memory it will occupy.

 An implementation typically has the property, in the absence of
 masking, that lanes are stored as a dense sequence of back-to-back
 values in memory, the same as a dense (gap-free) series of single
 scalar values in an array of the scalar type.

 In such cases memory order corresponds exactly to lane order.  The
 first vector lane value occupies the first position in memory, and so on,
 up to the length of the vector. Further, the memory order of stored
 vector lanes corresponds to increasing index values in a Java array or
 in a <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>.

 <p> Byte order for lane storage is chosen such that the stored
 vector values can be read or written as single primitive values,
 within the array or segment that holds the vector, producing the
 same values as the lane-wise values within the vector.
 This fact is independent of the convenient fiction that lane values
 inside of vectors are stored in little-endian order.

 <p> For example,
 <a href="FloatVector.html#fromArray(jdk.incubator.vector.VectorSpecies,float%5B%5D,int)"><code>FloatVector.fromArray(fsp,fa,i)</code></a>
 creates and returns a float vector of some particular species <code>fsp</code>,
 with elements loaded from some float array <code>fa</code>.
 The first lane is loaded from <code>fa[i]</code> and the last lane
 is initialized loaded from <code>fa[i+VL-1]</code>, where <code>VL</code>
 is the length of the vector as derived from the species <code>fsp</code>.
 Then, <a href="FloatVector.html#add(jdk.incubator.vector.Vector)"><code>fv=fv.add(fv2)</code></a>
 will produce another float vector of that species <code>fsp</code>,
 given a vector <code>fv2</code> of the same species <code>fsp</code>.
 Next, <a href="FloatVector.html#compare(jdk.incubator.vector.VectorOperators.Comparison,float)"><code>mnz=fv.compare(NE, 0.0f)</code></a> tests whether the result is zero,
 yielding a mask <code>mnz</code>.  The non-zero lanes (and only those
 lanes) can then be stored back into the original array elements
 using the statement
 <a href="FloatVector.html#intoArray(float%5B%5D,int,jdk.incubator.vector.VectorMask)"><code>fv.intoArray(fa,i,mnz)</code></a>.

 <h2><a id="expansion"></a>Expansions, contractions, and partial results</h2>

 Since vectors are fixed in size, occasions often arise where the
 logical result of an operation is not the same as the physical size
 of the proposed output vector.  To encourage user code that is as
 portable and predictable as possible, this API has a systematic
 approach to the design of such <em>resizing</em> vector operations.

 <p> As a basic principle, lane-wise operations are
 <em>length-invariant</em>, unless clearly marked otherwise.
 Length-invariance simply means that
 if <code>VLENGTH</code> lanes go into an operation, the same number
 of lanes come out, with nothing discarded and no extra padding.

 <p> As a second principle, sometimes in tension with the first,
 lane-wise operations are also <em>shape-invariant</em>, unless
 clearly marked otherwise.

 Shape-invariance means that <code>VSHAPE</code> is constant for typical
 computations.  Keeping the same shape throughout a computation
 helps ensure that scarce vector resources are efficiently used.
 (On some hardware platforms shape changes could cause unwanted
 effects like extra data movement instructions, round trips through
 memory, or pipeline bubbles.)

 <p> Tension between these principles arises when an operation
 produces a <em>logical result</em> that is too large for the
 required output <code>VSHAPE</code>.  In other cases, when a logical
 result is smaller than the capacity of the output <code>VSHAPE</code>,
 the positioning of the logical result is open to question, since
 the physical output vector must contain a mix of logical result and
 padding.

 <p> In the first case, of a too-large logical result being crammed
 into a too-small output <code>VSHAPE</code>, we say that data has
 <em>expanded</em>.  In other words, an <em>expansion operation</em>
 has caused the output shape to overflow.  Symmetrically, in the
 second case of a small logical result fitting into a roomy output
 <code>VSHAPE</code>, the data has <em>contracted</em>, and the
 <em>contraction operation</em> has required the output shape to pad
 itself with extra zero lanes.

 <p> In both cases we can speak of a parameter <code>M</code> which
 measures the <em>expansion ratio</em> or <em>contraction ratio</em>
 between the logical result size (in bits) and the bit-size of the
 actual output shape.  When vector shapes are changed, and lane
 sizes are not, <code>M</code> is just the integral ratio of the output
 shape to the logical result.  (With the possible exception of
 the <a href="VectorShape.html#S_Max_BIT">maximum shape</a>, all vector
 sizes are powers of two, and so the ratio <code>M</code> is always
 an integer.  In the hypothetical case of a non-integral ratio,
 the value <code>M</code> would be rounded up to the next integer,
 and then the same general considerations would apply.)

 <p> If the logical result is larger than the physical output shape,
 such a shape change must inevitably drop result lanes (all but
 <code>1/M</code> of the logical result).  If the logical size is smaller
 than the output, the shape change must introduce zero-filled lanes
 of padding (all but <code>1/M</code> of the physical output).  The first
 case, with dropped lanes, is an expansion, while the second, with
 padding lanes added, is a contraction.

 <p> Similarly, consider a lane-wise conversion operation which
 leaves the shape invariant but changes the lane size by a ratio of
 <code>M</code>.  If the logical result is larger than the output (or
 input), this conversion must reduce the <code>VLENGTH</code> lanes of the
 output by <code>M</code>, dropping all but <code>1/M</code> of the logical
 result lanes.  As before, the dropping of lanes is the hallmark of
 an expansion.  A lane-wise operation which contracts lane size by a
 ratio of <code>M</code> must increase the <code>VLENGTH</code> by the same
 factor <code>M</code>, filling the extra lanes with a zero padding
 value; because padding must be added this is a contraction.

 <p> It is also possible (though somewhat confusing) to change both
 lane size and container size in one operation which performs both
 lane conversion <em>and</em> reshaping.  If this is done, the same
 rules apply, but the logical result size is the product of the
 input size times any expansion or contraction ratio from the lane
 change size.

 <p> For completeness, we can also speak of <em>in-place
 operations</em> for the frequent case when resizing does not occur.
 With an in-place operation, the data is simply copied from logical
 output to its physical container with no truncation or padding.
 The ratio parameter <code>M</code> in this case is unity.

 <p> Note that the classification of contraction vs. expansion
 depends on the relative sizes of the logical result and the
 physical output container.  The size of the input container may be
 larger or smaller than either of the other two values, without
 changing the classification.  For example, a conversion from a
 128-bit shape to a 256-bit shape will be a contraction in many
 cases, but it would be an expansion if it were combined with a
 conversion from <code>byte</code> to <code>long</code>, since in that case
 the logical result would be 1024 bits in size.  This example also
 illustrates that a logical result does not need to correspond to
 any particular platform-supported vector shape.

 <p> Although lane-wise masked operations can be viewed as producing
 partial operations, they are not classified (in this API) as
 expansions or contractions.  A masked load from an array surely
 produces a partial vector, but there is no meaningful "logical
 output vector" that this partial result was contracted from.

 <p> Some care is required with these terms, because it is the
 <em>data</em>, not the <em>container size</em>, that is expanding
 or contracting, relative to the size of its output container.
 Thus, resizing a 128-bit input into 512-bit vector has the effect
 of a <em>contraction</em>.  Though the 128 bits of payload hasn't
 changed in size, we can say it "looks smaller" in its new 512-bit
 home, and this will capture the practical details of the situation.

 <p> If a vector method might expand its data, it accepts an extra
 <code>int</code> parameter called <code>part</code>, or the "part number".
 The part number must be in the range <code>[0..M-1]</code>, where
 <code>M</code> is the expansion ratio.  The part number selects one
 of <code>M</code> contiguous disjoint equally-sized blocks of lanes
 from the logical result and fills the physical output vector
 with this block of lanes.

 <p> Specifically, the lanes selected from the logical result of an
 expansion are numbered in the range <code>[R..R+L-1]</code>, where
 <code>L</code> is the <code>VLENGTH</code> of the physical output vector, and
 the origin of the block, <code>R</code>, is <code>part*L</code>.

 <p> A similar convention applies to any vector method that might
 contract its data.  Such a method also accepts an extra part number
 parameter (again called <code>part</code>) which steers the contracted
 data lanes one of <code>M</code> contiguous disjoint equally-sized
 blocks of lanes in the physical output vector.  The remaining lanes
 are filled with zero, or as specified by the method.

 <p> Specifically, the data is steered into the lanes numbered in the
 range <code>[R..R+L-1]</code>, where <code>L</code> is the <code>VLENGTH</code> of
 the logical result vector, and the origin of the block, <code>R</code>,
 is again a multiple of <code>L</code> selected by the part number,
 specifically <code>|part|*L</code>.

 <p> In the case of a contraction, the part number must be in the
 non-positive range <code>[-M+1..0]</code>.  This convention is adopted
 because some methods can perform both expansions and contractions,
 in a data-dependent manner, and the extra sign on the part number
 serves as an error check.  If vector method takes a part number and
 is invoked to perform an in-place operation (neither contracting
 nor expanding), the <code>part</code> parameter must be exactly zero.
 Part numbers outside the allowed ranges will elicit an indexing
 exception.  Note that in all cases a zero part number is valid, and
 corresponds to an operation which preserves as many lanes as
 possible from the beginning of the logical result, and places them
 into the beginning of the physical output container.  This is
 often a desirable default, so a part number of zero is safe
 in all cases and useful in most cases.

 <p> The various resizing operations of this API contract or expand
 their data as follows:
 <ul>

 <li>
 <a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>Vector.convert()</code></a>
 will expand (respectively, contract) its operand by ratio
 <code>M</code> if the
 <a href="#elementSize()">element size</a> of its output is
 larger (respectively, smaller) by a factor of <code>M</code>.
 If the element sizes of input and output are the same,
 then <code>convert()</code> is an in-place operation.

 <li>
 <a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)"><code>Vector.convertShape()</code></a>
 will expand (respectively, contract) its operand by ratio
 <code>M</code> if the bit-size of its logical result is
 larger (respectively, smaller) than the bit-size of its
 output shape.
 The size of the logical result is defined as the
 <a href="#elementSize()">element size</a> of the output,
 times the <code>VLENGTH</code> of its input.

 Depending on the ratio of the changed lane sizes, the logical size
 may be (in various cases) either larger or smaller than the input
 vector, independently of whether the operation is an expansion
 or contraction.

 <li>
 Since <a href="#castShape(jdk.incubator.vector.VectorSpecies,int)"><code>Vector.castShape()</code></a>
 is a convenience method for <code>convertShape()</code>, its classification
 as an expansion or contraction is the same as for <code>convertShape()</code>.

 <li>
 <a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)"><code>Vector.reinterpretShape()</code></a>
 is an expansion (respectively, contraction) by ratio <code>M</code> if the
 <a href="#bitSize()">vector bit-size</a> of its input is
 crammed into a smaller (respectively, dropped into a larger)
 output container by a factor of <code>M</code>.
 Otherwise it is an in-place operation.

 Since this method is a reinterpretation cast that can erase and
 redraw lane boundaries as well as modify shape, the input vector's
 lane size and lane count are irrelevant to its classification as
 expanding or contracting.

 <li>
 The <a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice()</code></a> methods expand
 by a ratio of <code>M=2</code>, because the single input slice is
 positioned and inserted somewhere within two consecutive background
 vectors.  The part number selects the first or second background
 vector, as updated by the inserted slice.
 Note that the corresponding
 <a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice()</code></a> methods, although inverse
 to the <code>unslice()</code> methods, do not contract their data
 and thus require no part number.  This is because
 <code>slice()</code> delivers a slice of exactly <code>VLENGTH</code>
 lanes extracted from two input vectors.
 </ul>

 The method <a href="VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)"><code>partLimit()</code></a> on <a href="VectorSpecies.html" title="interface in jdk.incubator.vector"><code>VectorSpecies</code></a> can be used, before any
 expanding or contracting operation is performed, to query the
 limiting value on a part parameter for a proposed expansion
 or contraction.  The value returned from <code>partLimit()</code> is
 positive for expansions, negative for contractions, and zero for
 in-place operations.  Its absolute value is the parameter <code>
 M</code>, and so it serves as an exclusive limit on valid part number
 arguments for the relevant methods.  Thus, for expansions, the
 <code>partLimit()</code> value <code>M</code> is the exclusive upper limit
 for part numbers, while for contractions the <code>partLimit()</code>
 value <code>-M</code> is the exclusive <em>lower</em> limit.

 <h2><a id="cross-lane"></a>Moving data across lane boundaries</h2>
 The cross-lane methods which do not redraw lanes or change species
 are more regularly structured and easier to reason about.
 These operations are:
 <ul>

 <li>The <a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice()</code></a> family of methods,
 which extract contiguous slice of <code>VLENGTH</code> fields from
 a given origin point within a concatenated pair of vectors.

 <li>The <a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice()</code></a> family of
 methods, which insert a contiguous slice of <code>VLENGTH</code> fields
 into a concatenated pair of vectors at a given origin point.

 <li>The <a href="#rearrange(jdk.incubator.vector.VectorShuffle)"><code>rearrange()</code></a> family of
 methods, which select an arbitrary set of <code>VLENGTH</code> lanes
 from one or two input vectors, and assemble them in an arbitrary
 order.  The selection and order of lanes is controlled by a
 <code>VectorShuffle</code> object, which acts as an routing table
 mapping source lanes to destination lanes.  A <code>VectorShuffle</code>
 can encode a mathematical permutation as well as many other
 patterns of data movement.

 <li>The <a href="#compress(jdk.incubator.vector.VectorMask)"><code>compress(VectorMask)</code></a> and <a href="#expand(jdk.incubator.vector.VectorMask)"><code>expand(VectorMask)</code></a>
 methods, which select up to <code>VLENGTH</code> lanes from an
 input vector, and assemble them in lane order.  The selection of lanes
 is controlled by a <code>VectorMask</code>, with set lane elements mapping, by
 compression or expansion in lane order, source lanes to destination lanes.

 </ul>
 <p> Some vector operations are not lane-wise, but rather move data
 across lane boundaries.  Such operations are typically rare in SIMD
 code, though they are sometimes necessary for specific algorithms
 that manipulate data formats at a low level, and/or require SIMD
 data to move in complex local patterns.  (Local movement in a small
 window of a large array of data is relatively unusual, although
 some highly patterned algorithms call for it.)  In this API such
 methods are always clearly recognizable, so that simpler lane-wise
 reasoning can be confidently applied to the rest of the code.

 <p> In some cases, vector lane boundaries are discarded and
 "redrawn from scratch", so that data in a given input lane might
 appear (in several parts) distributed through several output lanes,
 or (conversely) data from several input lanes might be consolidated
 into a single output lane.  The fundamental method which can redraw
 lanes boundaries is
 <a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)"><code>reinterpretShape()</code></a>.
 Built on top of this method, certain convenience methods such
 as <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a> or
 <a href="#reinterpretAsInts()"><code>reinterpretAsInts()</code></a> will
 (potentially) redraw lane boundaries, while retaining the
 same overall vector shape.

 <p> Operations which produce or consume a scalar result can be
 viewed as very simple cross-lane operations.  Methods in the
 <a href="#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)"><code>reduceLanes()</code></a> family fold together all lanes (or mask-selected
 lanes) of a method and return a single result.  As an inverse, the
 <a href="#broadcast(long)"><code>broadcast</code></a> family of methods can be thought
 of as crossing lanes in the other direction, from a scalar to all
 lanes of the output vector.  Single-lane access methods such as
 <code>lane(I)</code> or <code>withLane(I,E)</code> might also be regarded as
 very simple cross-lane operations.

 <p> Likewise, a method which moves a non-byte vector to or from a
 byte array could be viewed as a cross-lane operation, because the
 vector lanes must be distributed into separate bytes, or (in the
 other direction) consolidated from array bytes.</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd><h2>Hardware platform dependencies and limitations</h2>

 The Vector API is to accelerate computations in style of Single
 Instruction Multiple Data (SIMD), using available hardware
 resources such as vector hardware registers and vector hardware
 instructions.  The API is designed to make effective use of
 multiple SIMD hardware platforms.

 <p> This API will also work correctly even on Java platforms which
 do not include specialized hardware support for SIMD computations.
 The Vector API is not likely to provide any special performance
 benefit on such platforms.

 <p> Currently the implementation is optimized to work best on:

 <ul>

 <li> Intel x64 platforms supporting at least AVX2 up to AVX-512.
 Masking using mask registers and mask accepting hardware
 instructions on AVX-512 are not currently supported.

 <li> ARM AArch64 platforms supporting NEON.  Although the API has
 been designed to ensure ARM SVE instructions can be supported
 (vector sizes between 128 to 2048 bits) there is currently no
 implementation of such instructions and the general masking
 capability.

 </ul>
 The implementation currently supports masked lane-wise operations
 in a cross-platform manner by composing the unmasked lane-wise
 operation with <a href="#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>blend</code></a> as in
 the expression <code>a.blend(a.lanewise(op, b), m)</code>, where
 <code>a</code> and <code>b</code> are vectors, <code>op</code> is the vector
 operation, and <code>m</code> is the mask.

 <p> The implementation does not currently support optimal
 vectorized instructions for floating point transcendental
 functions (such as operators <a href="VectorOperators.html#SIN"><code>SIN</code></a>
 and <a href="VectorOperators.html#LOG"><code>LOG</code></a>).

 <h2>No boxing of primitives</h2>

 Although a vector type like <code>Vector&lt;Integer&gt;</code> may seem to
 work with boxed <code>Integer</code> values, the overheads associated
 with boxing are avoided by having each vector subtype work
 internally on lane values of the actual <code>ETYPE</code>, such as
 <code>int</code>.

 <h2>Value-based classes and identity operations</h2>

 <code>Vector</code>, along with all of its subtypes and many of its
 helper types like <code>VectorMask</code> and <code>VectorShuffle</code>, is a
 <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>
 class.

 <p> Once created, a vector is never mutated, not even if only
 <a href="IntVector.html#withLane(int,int)">a single lane is changed</a>.
 A new vector is always created to hold a new configuration
 of lane values.  The unavailability of mutative methods is a
 necessary consequence of suppressing the object identity of
 all vectors, as value-based classes.

 <p> With <code>Vector</code>,

 <!-- The following paragraph is shared verbatim
   -- between Vector.java and package-info.java -->
 identity-sensitive operations such as <code>==</code> may yield
 unpredictable results, or reduced performance.  Oddly enough,
 <a href="#equals(java.lang.Object)"><code>v.equals(w)</code></a> is likely to be faster
 than <code>v==w</code>, since <code>equals</code> is <em>not</em> an identity
 sensitive method.

 Also, these objects can be stored in locals and parameters and as
 <code>static final</code> constants, but storing them in other Java
 fields or in array elements, while semantically valid, may incur
 performance penalties.
 <!-- The preceding paragraph is shared verbatim
   -- between Vector.java and package-info.java --></dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#abs()" class="member-name-link">abs</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the absolute value of this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#add(jdk.incubator.vector.Vector)" class="member-name-link">add</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Adds this vector to a second input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#add(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">add</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Adds this vector to a second input vector, selecting lanes
 under the control of a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#addIndex(int)" class="member-name-link">addIndex</a><wbr>(int&nbsp;scale)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Adds the lanes of this vector to their corresponding
 lane numbers, scaled by a given constant.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#bitSize()" class="member-name-link">bitSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the total size, in bits, of this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#blend(long,jdk.incubator.vector.VectorMask)" class="member-name-link">blend</a><wbr>(long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Replaces selected lanes of this vector with
 a scalar value
 under the control of a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">blend</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Replaces selected lanes of this vector with
 corresponding lanes from a second input vector
 under the control of a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#broadcast(long)" class="member-name-link">broadcast</a><wbr>(long&nbsp;e)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a vector of the same species as this one
 where all lane elements are set to
 the primitive value <code>e</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#byteSize()" class="member-name-link">byteSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the total size, in bytes, of this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#castShape(jdk.incubator.vector.VectorSpecies,int)" class="member-name-link">castShape</a><wbr>(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;rsp,
 int&nbsp;part)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convenience method for converting a vector from one lane type
 to another, reshaping as needed when lane sizes change.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#check(java.lang.Class)" class="member-name-link">check</a><wbr>(<a href="../../../../java.base/java/lang/Class.html" title="class in java.lang">Class</a>&lt;F&gt;&nbsp;elementType)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Checks that this vector has the given element type,
 and returns this vector unchanged.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#check(jdk.incubator.vector.VectorSpecies)" class="member-name-link">check</a><wbr>(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;species)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Checks that this vector has the given species,
 and returns this vector unchanged.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,long)" class="member-name-link">compare</a><wbr>(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 long&nbsp;e)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests this vector by comparing it with an input scalar,
 according to the given comparison operation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,long,jdk.incubator.vector.VectorMask)" class="member-name-link">compare</a><wbr>(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests this vector by comparing it with an input scalar,
 according to the given comparison operation,
 in lanes selected by a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)" class="member-name-link">compare</a><wbr>(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests this vector by comparing it with another input vector,
 according to the given comparison operation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">compare</a><wbr>(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests this vector by comparing it with another input vector,
 according to the given comparison operation,
 in lanes selected by a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#compress(jdk.incubator.vector.VectorMask)" class="member-name-link">compress</a><wbr>(<a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Compresses the lane elements of this vector selecting lanes
 under the control of a specific mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)" class="member-name-link">convert</a><wbr>(<a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">VectorOperators.Conversion</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>,<wbr>F&gt;&nbsp;conv,
 int&nbsp;part)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convert this vector to a vector of the same shape and a new
 element type, converting lane values from the current <code>ETYPE</code>
 to a new lane type (called <code>FTYPE</code> here) according to the
 indicated <a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">conversion</a>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)" class="member-name-link">convertShape</a><wbr>(<a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">VectorOperators.Conversion</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>,<wbr>F&gt;&nbsp;conv,
 <a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;rsp,
 int&nbsp;part)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Converts this vector to a vector of the given species, shape and
 element type, converting lane values from the current <code>ETYPE</code>
 to a new lane type (called <code>FTYPE</code> here) according to the
 indicated <a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">conversion</a>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#div(jdk.incubator.vector.Vector)" class="member-name-link">div</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Divides this vector by a second input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#div(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">div</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Divides this vector by a second input vector
 under the control of a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#elementSize()" class="member-name-link">elementSize</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the size of each lane, in bits, of this vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="../../../../java.base/java/lang/Class.html" title="class in java.lang">Class</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#elementType()" class="member-name-link">elementType</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the primitive <a href="Vector.html#ETYPE">element type</a>
 (<code>ETYPE</code>) of this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#eq(jdk.incubator.vector.Vector)" class="member-name-link">eq</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests if this vector is equal to another input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#equals(java.lang.Object)" class="member-name-link">equals</a><wbr>(<a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;obj)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Indicates whether this vector is identical to some other object.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#expand(jdk.incubator.vector.VectorMask)" class="member-name-link">expand</a><wbr>(<a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Expands the lane elements of this vector
 under the control of a specific mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hashCode()" class="member-name-link">hashCode</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a hash code value for the vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)" class="member-name-link">intoMemorySegment</a><wbr>(<a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&nbsp;ms,
 long&nbsp;offset,
 <a href="../../../../java.base/java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;bo)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Stores this vector into a <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">memory segment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>
 starting at an offset using explicit byte order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder,jdk.incubator.vector.VectorMask)" class="member-name-link">intoMemorySegment</a><wbr>(<a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&nbsp;ms,
 long&nbsp;offset,
 <a href="../../../../java.base/java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;bo,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Stores this vector into a <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">memory segment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>
 starting at an offset using explicit byte order and a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,long)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 long&nbsp;e)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the lane values of this vector
 with the value of a broadcast scalar.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,long,jdk.incubator.vector.VectorMask)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector,
 with selection of lane elements controlled by a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector,
 with selection of lane elements controlled by a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Ternary.html" title="interface in jdk.incubator.vector">VectorOperators.Ternary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v2)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the corresponding lane values of this vector
 with the lanes of a second and a third input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Ternary.html" title="interface in jdk.incubator.vector">VectorOperators.Ternary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v2,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Combines the corresponding lane values of this vector
 with the lanes of a second and a third input vector,
 with selection of lane elements controlled by a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Unary.html" title="interface in jdk.incubator.vector">VectorOperators.Unary</a>&nbsp;op)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Operates on the lane values of this vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)" class="member-name-link">lanewise</a><wbr>(<a href="VectorOperators.Unary.html" title="interface in jdk.incubator.vector">VectorOperators.Unary</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Operates on the lane values of this vector,
 with selection of lane elements controlled by a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#length()" class="member-name-link">length</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the lane count, or <a href="Vector.html#VLENGTH">vector length</a>
 (<code>VLENGTH</code>).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#lt(jdk.incubator.vector.Vector)" class="member-name-link">lt</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests if this vector is less than another input vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#maskAll(boolean)" class="member-name-link">maskAll</a><wbr>(boolean&nbsp;bit)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a mask of same species as this vector,
 where each lane is set or unset according to given
 single boolean, which is broadcast to all lanes.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#max(jdk.incubator.vector.Vector)" class="member-name-link">max</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Computes the larger of this vector and a second input vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#min(jdk.incubator.vector.Vector)" class="member-name-link">min</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Computes the smaller of this vector and a second input vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#mul(jdk.incubator.vector.Vector)" class="member-name-link">mul</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Multiplies this vector by a second input vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#mul(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">mul</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Multiplies this vector by a second input vector
 under the control of a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#neg()" class="member-name-link">neg</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Negates this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#rearrange(jdk.incubator.vector.VectorShuffle)" class="member-name-link">rearrange</a><wbr>(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Rearranges the lane elements of this vector, selecting lanes
 under the control of a specific shuffle.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)" class="member-name-link">rearrange</a><wbr>(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Rearranges the lane elements of two vectors, selecting lanes
 under the control of a specific shuffle, using both normal and
 exceptional indexes in the shuffle to steer data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)" class="member-name-link">rearrange</a><wbr>(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Rearranges the lane elements of this vector, selecting lanes
 under the control of a specific shuffle and a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)" class="member-name-link">reduceLanesToLong</a><wbr>(<a href="VectorOperators.Associative.html" title="interface in jdk.incubator.vector">VectorOperators.Associative</a>&nbsp;op)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a value accumulated from all the lanes of this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)" class="member-name-link">reduceLanesToLong</a><wbr>(<a href="VectorOperators.Associative.html" title="interface in jdk.incubator.vector">VectorOperators.Associative</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a value accumulated from selected lanes of this vector,
 controlled by a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="ByteVector.html" title="class in jdk.incubator.vector">ByteVector</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsBytes()" class="member-name-link">reinterpretAsBytes</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Views this vector as a vector of the same shape
 and contents but a lane type of <code>byte</code>,
 where the bytes are extracted from the lanes
 according to little-endian order.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="DoubleVector.html" title="class in jdk.incubator.vector">DoubleVector</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsDoubles()" class="member-name-link">reinterpretAsDoubles</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>double</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="FloatVector.html" title="class in jdk.incubator.vector">FloatVector</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsFloats()" class="member-name-link">reinterpretAsFloats</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>float</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="IntVector.html" title="class in jdk.incubator.vector">IntVector</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsInts()" class="member-name-link">reinterpretAsInts</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>int</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="LongVector.html" title="class in jdk.incubator.vector">LongVector</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsLongs()" class="member-name-link">reinterpretAsLongs</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>long</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="ShortVector.html" title="class in jdk.incubator.vector">ShortVector</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretAsShorts()" class="member-name-link">reinterpretAsShorts</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>short</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract &lt;F&gt;&nbsp;<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)" class="member-name-link">reinterpretShape</a><wbr>(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;species,
 int&nbsp;part)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Transforms this vector to a vector of the given species of
 element type <code>F</code>, reinterpreting the bytes of this
 vector without performing any value conversions.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#selectFrom(jdk.incubator.vector.Vector)" class="member-name-link">selectFrom</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Using index values stored in the lanes of this vector,
 assemble values stored in second vector <code>v</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#selectFrom(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">selectFrom</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Using index values stored in the lanes of this vector,
 assemble values stored in second vector, under the control
 of a mask.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorShape.html" title="enum class in jdk.incubator.vector">VectorShape</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#shape()" class="member-name-link">shape</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the shape of this vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#slice(int)" class="member-name-link">slice</a><wbr>(int&nbsp;origin)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Slices a segment of adjacent lanes, starting at a given
 <code>origin</code> lane in the current vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#slice(int,jdk.incubator.vector.Vector)" class="member-name-link">slice</a><wbr>(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Slices a segment of adjacent lanes, starting at a given
 <code>origin</code> lane in the current vector, and continuing (as
 needed) into an immediately following vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#slice(int,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">slice</a><wbr>(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Slices a segment of adjacent lanes
 under the control of a mask,
 starting at a given
 <code>origin</code> lane in the current vector, and continuing (as
 needed) into an immediately following vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#species()" class="member-name-link">species</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the species of this vector.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#sub(jdk.incubator.vector.Vector)" class="member-name-link">sub</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Subtracts a second input vector from this vector.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#sub(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)" class="member-name-link">sub</a><wbr>(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Subtracts a second input vector from this vector
 under the control of a mask.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#test(jdk.incubator.vector.VectorOperators.Test)" class="member-name-link">test</a><wbr>(<a href="VectorOperators.Test.html" title="interface in jdk.incubator.vector">VectorOperators.Test</a>&nbsp;op)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Tests the lanes of this vector
 according to the given operation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#test(jdk.incubator.vector.VectorOperators.Test,jdk.incubator.vector.VectorMask)" class="member-name-link">test</a><wbr>(<a href="VectorOperators.Test.html" title="interface in jdk.incubator.vector">VectorOperators.Test</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Test selected lanes of this vector,
 according to the given operation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toArray()" class="member-name-link">toArray</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a packed array containing all the lane values.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract double[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toDoubleArray()" class="member-name-link">toDoubleArray</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a <code>double[]</code> array containing all
 the lane values, converted to the type <code>double</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract int[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toIntArray()" class="member-name-link">toIntArray</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns an <code>int[]</code> array containing all
 the lane values, converted to the type <code>int</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract long[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toLongArray()" class="member-name-link">toLongArray</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a <code>long[]</code> array containing all
 the lane values, converted to the type <code>long</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toShuffle()" class="member-name-link">toShuffle</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Converts this vector into a shuffle, converting the lane values
 to <code>int</code> and regarding them as source indexes.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="../../../../java.base/java/lang/String.html" title="class in java.lang">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toString()" class="member-name-link">toString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a string representation of this vector, of the form
 <code>"[0,1,2...]"</code>, reporting the lane values of this
 vector, in lane order.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#unslice(int)" class="member-name-link">unslice</a><wbr>(int&nbsp;origin)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reverses a <a href="#slice(int)">slice()</a>, inserting
 the current vector as a slice within a "background" input
 of zero lane values.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#unslice(int,jdk.incubator.vector.Vector,int)" class="member-name-link">unslice</a><wbr>(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;w,
 int&nbsp;part)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reverses a <a href="#slice(int,jdk.incubator.vector.Vector)">slice()</a>, inserting
 the current vector as a slice within another "background" input
 vector, which is regarded as one or the other input to a
 hypothetical subsequent <code>slice()</code> operation.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)" class="member-name-link">unslice</a><wbr>(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;w,
 int&nbsp;part,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Reverses a <a href="#slice(int,jdk.incubator.vector.Vector)">slice()</a>, inserting
 (under the control of a mask)
 the current vector as a slice within another "background" input
 vector, which is regarded as one or the other input to a
 hypothetical subsequent <code>slice()</code> operation.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;?&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#viewAsFloatingLanes()" class="member-name-link">viewAsFloatingLanes</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Views this vector as a vector of the same shape, length, and
 contents, but a lane type that is a floating-point type.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>abstract <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;?&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#viewAsIntegralLanes()" class="member-name-link">viewAsIntegralLanes</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Views this vector as a vector of the same shape, length, and
 contents, but a lane type that is not a floating-point type.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-jdk.internal.vm.vector.VectorSupport.VectorPayload">Methods declared in class&nbsp;jdk.internal.vm.vector.VectorSupport.VectorPayload</h3>
<code>getPayload</code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class&nbsp;java.lang.<a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></h3>
<code><a href="../../../../java.base/java/lang/Object.html#clone()">clone</a>, <a href="../../../../java.base/java/lang/Object.html#finalize()">finalize</a>, <a href="../../../../java.base/java/lang/Object.html#getClass()">getClass</a>, <a href="../../../../java.base/java/lang/Object.html#notify()">notify</a>, <a href="../../../../java.base/java/lang/Object.html#notifyAll()">notifyAll</a>, <a href="../../../../java.base/java/lang/Object.html#wait()">wait</a>, <a href="../../../../java.base/java/lang/Object.html#wait(long)">wait</a>, <a href="../../../../java.base/java/lang/Object.html#wait(long,int)">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="species()">
<h3>species</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">species</span>()</div>
<div class="block">Returns the species of this vector.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the species of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="elementType()">
<h3>elementType</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="../../../../java.base/java/lang/Class.html" title="class in java.lang">Class</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">elementType</span>()</div>
<div class="block">Returns the primitive <a href="Vector.html#ETYPE">element type</a>
 (<code>ETYPE</code>) of this vector.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>This is the same value as <code>this.species().elementType()</code>.</dd>
<dt>Returns:</dt>
<dd>the primitive element type of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="elementSize()">
<h3>elementSize</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">elementSize</span>()</div>
<div class="block">Returns the size of each lane, in bits, of this vector.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>This is the same value as <code>this.species().elementSize()</code>.</dd>
<dt>Returns:</dt>
<dd>the lane size, in bits, of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="shape()">
<h3>shape</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorShape.html" title="enum class in jdk.incubator.vector">VectorShape</a></span>&nbsp;<span class="element-name">shape</span>()</div>
<div class="block">Returns the shape of this vector.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>This is the same value as <code>this.species().vectorShape()</code>.</dd>
<dt>Returns:</dt>
<dd>the shape of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="length()">
<h3>length</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">length</span>()</div>
<div class="block">Returns the lane count, or <a href="Vector.html#VLENGTH">vector length</a>
 (<code>VLENGTH</code>).</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the lane count</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="bitSize()">
<h3>bitSize</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">bitSize</span>()</div>
<div class="block">Returns the total size, in bits, of this vector.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>This is the same value as <code>this.shape().vectorBitSize()</code>.</dd>
<dt>Returns:</dt>
<dd>the total size, in bits, of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="byteSize()">
<h3>byteSize</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">byteSize</span>()</div>
<div class="block">Returns the total size, in bytes, of this vector.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>This is the same value as <code>this.bitSize()/Byte.SIZE</code>.</dd>
<dt>Returns:</dt>
<dd>the total size, in bytes, of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Unary)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Unary.html" title="interface in jdk.incubator.vector">VectorOperators.Unary</a>&nbsp;op)</span></div>
<div class="block">Operates on the lane values of this vector.

 This is a <a href="Vector.html#lane-wise">lane-wise</a>
 unary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to process lane values</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the input vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#NEG"><code>VectorOperators.NEG</code></a></li>
<li><a href="VectorOperators.html#NOT"><code>VectorOperators.NOT</code></a></li>
<li><a href="VectorOperators.html#SIN"><code>VectorOperators.SIN</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Unary,VectorMask)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Ternary,Vector,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Unary.html" title="interface in jdk.incubator.vector">VectorOperators.Unary</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Operates on the lane values of this vector,
 with selection of lane elements controlled by a mask.

 This is a lane-wise unary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to process lane values</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the input vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise(VectorOperators.Unary)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector.

 This is a <a href="Vector.html#lane-wise">lane-wise</a>
 binary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>v</code> - the input vector</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the two input vectors</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#ADD"><code>VectorOperators.ADD</code></a></li>
<li><a href="VectorOperators.html#XOR"><code>VectorOperators.XOR</code></a></li>
<li><a href="VectorOperators.html#ATAN2"><code>VectorOperators.ATAN2</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise(VectorOperators.Unary)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Ternary,Vector, Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector,
 with selection of lane elements controlled by a mask.

 This is a lane-wise binary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>v</code> - the second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the two input vectors</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Binary,long)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 long&nbsp;e)</span></div>
<div class="block">Combines the lane values of this vector
 with the value of a broadcast scalar.

 This is a lane-wise binary operation which applies
 the selected operation to each lane.
 The return value will be equal to this expression:
 <code>this.lanewise(op, this.broadcast(e))</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.  This rule is enforced
 by the implicit call to <code>broadcast()</code>.
 <p>
 Subtypes improve on this method by sharpening
 the method return type and
 the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>e</code> - the input scalar</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the input vector and the scalar</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the given <code>long</code> value cannot
         be represented by the right operand type
         of the vector operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#broadcast(long)"><code>broadcast(long)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,long,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,long,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Binary,long,jdk.incubator.vector.VectorMask)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Binary.html" title="interface in jdk.incubator.vector">VectorOperators.Binary</a>&nbsp;op,
 long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Combines the corresponding lane values of this vector
 with those of a second input vector,
 with selection of lane elements controlled by a mask.

 This is a lane-wise binary operation which applies
 the selected operation to each lane.
 The second operand is a broadcast integral value.
 The return value will be equal to this expression:
 <code>this.lanewise(op, this.broadcast(e), m)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.  This rule is enforced
 by the implicit call to <code>broadcast()</code>.
 <p>
 Subtypes improve on this method by sharpening
 the method return type and
 the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>e</code> - the input scalar</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the input vector and the scalar</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the given <code>long</code> value cannot
         be represented by the right operand type
         of the vector operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#broadcast(long)"><code>broadcast(long)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Ternary.html" title="interface in jdk.incubator.vector">VectorOperators.Ternary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v2)</span></div>
<div class="block">Combines the corresponding lane values of this vector
 with the lanes of a second and a third input vector.

 This is a <a href="Vector.html#lane-wise">lane-wise</a>
 ternary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>v1</code> - the second input vector</dd>
<dd><code>v2</code> - the third input vector</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the three input vectors</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#BITWISE_BLEND"><code>VectorOperators.BITWISE_BLEND</code></a></li>
<li><a href="VectorOperators.html#FMA"><code>VectorOperators.FMA</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise(VectorOperators.Unary)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>lanewise</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lanewise</span><wbr><span class="parameters">(<a href="VectorOperators.Ternary.html" title="interface in jdk.incubator.vector">VectorOperators.Ternary</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v2,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Combines the corresponding lane values of this vector
 with the lanes of a second and a third input vector,
 with selection of lane elements controlled by a mask.

 This is a lane-wise ternary operation which applies
 the selected operation to each lane.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>v1</code> - the second input vector</dd>
<dd><code>v2</code> - the third input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of applying the operation lane-wise
         to the three input vectors</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Ternary,jdk.incubator.vector.Vector,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Ternary,Vector,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(jdk.incubator.vector.Vector)">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Adds this vector to a second input vector.

 This is a lane-wise binary operation which applies
 the primitive addition operation (<code>+</code>)
 to each pair of corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#ADD"><code>ADD</code></a><code>, v)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the result of adding this vector to the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#add(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>add(Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#add(int)"><code>IntVector.add(int)</code></a></li>
<li><a href="VectorOperators.html#ADD"><code>VectorOperators.ADD</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int)"><code>IntVector.lanewise(VectorOperators.Binary,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="add(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>add</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">add</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Adds this vector to a second input vector, selecting lanes
 under the control of a mask.

 This is a masked lane-wise binary operation which applies
 the primitive addition operation (<code>+</code>)
 to each pair of corresponding lane values.

 For any lane unset in the mask, the primitive operation is
 suppressed and this vector retains the original value stored in
 that lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#ADD"><code>ADD</code></a><code>, v, m)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of adding this vector to the given vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#add(jdk.incubator.vector.Vector)"><code>add(Vector)</code></a></li>
<li><a href="IntVector.html#add(int,jdk.incubator.vector.VectorMask)"><code>IntVector.add(int,VectorMask)</code></a></li>
<li><a href="VectorOperators.html#ADD"><code>VectorOperators.ADD</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)"><code>IntVector.lanewise(VectorOperators.Binary,int,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sub(jdk.incubator.vector.Vector)">
<h3>sub</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">sub</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Subtracts a second input vector from this vector.

 This is a lane-wise binary operation which applies
 the primitive subtraction operation (<code>-</code>)
 to each pair of corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#SUB"><code>SUB</code></a><code>, v)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the result of subtracting the second input vector from this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#sub(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>sub(Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#sub(int)"><code>IntVector.sub(int)</code></a></li>
<li><a href="VectorOperators.html#SUB"><code>VectorOperators.SUB</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int)"><code>IntVector.lanewise(VectorOperators.Binary,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sub(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>sub</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">sub</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Subtracts a second input vector from this vector
 under the control of a mask.

 This is a masked lane-wise binary operation which applies
 the primitive subtraction operation (<code>-</code>)
 to each pair of corresponding lane values.

 For any lane unset in the mask, the primitive operation is
 suppressed and this vector retains the original value stored in
 that lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#SUB"><code>SUB</code></a><code>, v, m)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of subtracting the second input vector from this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#sub(jdk.incubator.vector.Vector)"><code>sub(Vector)</code></a></li>
<li><a href="IntVector.html#sub(int,jdk.incubator.vector.VectorMask)"><code>IntVector.sub(int,VectorMask)</code></a></li>
<li><a href="VectorOperators.html#SUB"><code>VectorOperators.SUB</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)"><code>IntVector.lanewise(VectorOperators.Binary,int,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mul(jdk.incubator.vector.Vector)">
<h3>mul</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">mul</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Multiplies this vector by a second input vector.

 This is a lane-wise binary operation which applies
 the primitive multiplication operation (<code>*</code>)
 to each pair of corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#MUL"><code>MUL</code></a><code>, v)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the result of multiplying this vector by the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#mul(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>mul(Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#mul(int)"><code>IntVector.mul(int)</code></a></li>
<li><a href="VectorOperators.html#MUL"><code>VectorOperators.MUL</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int)"><code>IntVector.lanewise(VectorOperators.Binary,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mul(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>mul</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">mul</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Multiplies this vector by a second input vector
 under the control of a mask.

 This is a lane-wise binary operation which applies
 the primitive multiplication operation (<code>*</code>)
 to each pair of corresponding lane values.

 For any lane unset in the mask, the primitive operation is
 suppressed and this vector retains the original value stored in
 that lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#MUL"><code>MUL</code></a><code>, v, m)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of multiplying this vector by the given vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#mul(jdk.incubator.vector.Vector)"><code>mul(Vector)</code></a></li>
<li><a href="IntVector.html#mul(int,jdk.incubator.vector.VectorMask)"><code>IntVector.mul(int,VectorMask)</code></a></li>
<li><a href="VectorOperators.html#MUL"><code>VectorOperators.MUL</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int,jdk.incubator.vector.VectorMask)"><code>IntVector.lanewise(VectorOperators.Binary,int,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="div(jdk.incubator.vector.Vector)">
<h3>div</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">div</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Divides this vector by a second input vector.

 This is a lane-wise binary operation which applies
 the primitive division operation (<code>/</code>)
 to each pair of corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#DIV"><code>DIV</code></a><code>, v)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>If the underlying scalar operator does not support
 division by zero, but is presented with a zero divisor,
 an <code>ArithmeticException</code> will be thrown.</dd>
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the result of dividing this vector by the second input vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArithmeticException.html" title="class in java.lang">ArithmeticException</a></code> - if any lane
         in <code>v</code> is zero
         and <code>ETYPE</code> is not <code>float</code> or <code>double</code>.</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#div(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>div(Vector,VectorMask)</code></a></li>
<li><a href="DoubleVector.html#div(double)"><code>DoubleVector.div(double)</code></a></li>
<li><a href="VectorOperators.html#DIV"><code>VectorOperators.DIV</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="IntVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,int)"><code>IntVector.lanewise(VectorOperators.Binary,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="div(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>div</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">div</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Divides this vector by a second input vector
 under the control of a mask.

 This is a lane-wise binary operation which applies
 the primitive division operation (<code>/</code>)
 to each pair of corresponding lane values.

 For any lane unset in the mask, the primitive operation is
 suppressed and this vector retains the original value stored in
 that lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#DIV"><code>DIV</code></a><code>, v, m)</code>.

 <p>
 As a full-service named operation, this method
 comes in masked and unmasked overloadings, and
 (in subclasses) also comes in scalar-broadcast
 overloadings (both masked and unmasked).</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>If the underlying scalar operator does not support
 division by zero, but is presented with a zero divisor,
 an <code>ArithmeticException</code> will be thrown.</dd>
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the result of dividing this vector by the second input vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArithmeticException.html" title="class in java.lang">ArithmeticException</a></code> - if any lane selected by <code>m</code>
         in <code>v</code> is zero
         and <code>ETYPE</code> is not <code>float</code> or <code>double</code>.</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#div(jdk.incubator.vector.Vector)"><code>div(Vector)</code></a></li>
<li><a href="DoubleVector.html#div(double,jdk.incubator.vector.VectorMask)"><code>DoubleVector.div(double,VectorMask)</code></a></li>
<li><a href="VectorOperators.html#DIV"><code>VectorOperators.DIV</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
<li><a href="DoubleVector.html#lanewise(jdk.incubator.vector.VectorOperators.Binary,double,jdk.incubator.vector.VectorMask)"><code>DoubleVector.lanewise(VectorOperators.Binary,double,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="neg()">
<h3>neg</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">neg</span>()</div>
<div class="block">Negates this vector.

 This is a lane-wise unary operation which applies
 the primitive negation operation (<code>-x</code>)
 to each input lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#NEG"><code>NEG</code></a><code>)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This method has no masked variant, but the corresponding
 masked operation can be obtained from the
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)">lanewise method</a>.</dd>
<dt>Returns:</dt>
<dd>the negation of this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#NEG"><code>VectorOperators.NEG</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise(VectorOperators.Unary)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Unary,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="abs()">
<h3>abs</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">abs</span>()</div>
<div class="block">Returns the absolute value of this vector.

 This is a lane-wise unary operation which applies
 the method <code>Math.abs</code>
 to each input lane.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#ABS"><code>ABS</code></a><code>)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This method has no masked variant, but the corresponding
 masked operation can be obtained from the
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)">lanewise method</a>.</dd>
<dt>Returns:</dt>
<dd>the absolute value of this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#ABS"><code>VectorOperators.ABS</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary)"><code>lanewise(VectorOperators.Unary)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Unary,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Unary,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="min(jdk.incubator.vector.Vector)">
<h3>min</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">min</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Computes the smaller of this vector and a second input vector.

 This is a lane-wise binary operation which applies the
 operation <code>Math.min()</code> to each pair of
 corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#MIN"><code>MIN</code></a><code>, v)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This is not a full-service named operation like
 <a href="#add(jdk.incubator.vector.Vector)"><code>add()</code></a>.  A masked version of
 this operation is not directly available
 but may be obtained via the masked version of
 <code>lanewise</code>.  Subclasses define an additional
 scalar-broadcast overloading of this method.</dd>
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the lanewise minimum of this vector and the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="IntVector.html#min(int)"><code>IntVector.min(int)</code></a></li>
<li><a href="VectorOperators.html#MIN"><code>VectorOperators.MIN</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="max(jdk.incubator.vector.Vector)">
<h3>max</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">max</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Computes the larger of this vector and a second input vector.

 This is a lane-wise binary operation which applies the
 operation <code>Math.max()</code> to each pair of
 corresponding lane values.

 This method is also equivalent to the expression
 <a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise</code></a><code>(</code><a href="VectorOperators.html#MAX"><code>MAX</code></a><code>, v)</code>.

 <p>
 This is not a full-service named operation like
 <a href="#add(jdk.incubator.vector.Vector)"><code>add()</code></a>.  A masked version of
 this operation is not directly available
 but may be obtained via the masked version of
 <code>lanewise</code>.  Subclasses define an additional
 scalar-broadcast overloading of this method.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the lanewise maximum of this vector and the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="IntVector.html#max(int)"><code>IntVector.max(int)</code></a></li>
<li><a href="VectorOperators.html#MAX"><code>VectorOperators.MAX</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector)"><code>lanewise(VectorOperators.Binary,Vector)</code></a></li>
<li><a href="#lanewise(jdk.incubator.vector.VectorOperators.Binary,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>lanewise(VectorOperators.Binary,Vector,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)">
<h3>reduceLanesToLong</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">reduceLanesToLong</span><wbr><span class="parameters">(<a href="VectorOperators.Associative.html" title="interface in jdk.incubator.vector">VectorOperators.Associative</a>&nbsp;op)</span></div>
<div class="block">Returns a value accumulated from all the lanes of this vector.

 This is an associative cross-lane reduction operation which
 applies the specified operation to all the lane elements.
 The return value will be equal to this expression:
 <code>(long) ((EVector)this).reduceLanes(op)</code>, where <code>EVector</code>
 is the vector class specific to this vector's element type
 <code>ETYPE</code>.
 <p>
 In the case of operations <code>ADD</code> and <code>MUL</code>,
 when <code>ETYPE</code> is <code>float</code> or <code>double</code>,
 the precise result, before casting, will reflect the choice
 of an arbitrary order of operations, which may even vary over time.
 For further details see the section
 <a href="VectorOperators.html#fp_assoc">Operations on floating point vectors</a>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>If the <code>ETYPE</code> is <code>float</code> or <code>double</code>,
 this operation can lose precision and/or range, as a
 normal part of casting the result down to <code>long</code>.

 Usually
 <a href="IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)">strongly typed access</a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dt>Returns:</dt>
<dd>the accumulated result, cast to <code>long</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)"><code>reduceLanesToLong(VectorOperators.Associative,VectorMask)</code></a></li>
<li><a href="IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)"><code>IntVector.reduceLanes(VectorOperators.Associative)</code></a></li>
<li><a href="FloatVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative)"><code>FloatVector.reduceLanes(VectorOperators.Associative)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)">
<h3>reduceLanesToLong</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">long</span>&nbsp;<span class="element-name">reduceLanesToLong</span><wbr><span class="parameters">(<a href="VectorOperators.Associative.html" title="interface in jdk.incubator.vector">VectorOperators.Associative</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Returns a value accumulated from selected lanes of this vector,
 controlled by a mask.

 This is an associative cross-lane reduction operation which
 applies the specified operation to the selected lane elements.
 The return value will be equal to this expression:
 <code>(long) ((EVector)this).reduceLanes(op, m)</code>, where <code>EVector</code>
 is the vector class specific to this vector's element type
 <code>ETYPE</code>.
 <p>
 If no elements are selected, an operation-specific identity
 value is returned.
 <ul>
 <li>
 If the operation is <code>ADD</code>, <code>XOR</code>, or <code>OR</code>,
 then the identity value is zero.
 <li>
 If the operation is <code>MUL</code>,
 then the identity value is one.
 <li>
 If the operation is <code>AND</code>,
 then the identity value is minus one (all bits set).
 <li>
 If the operation is <code>MAX</code>,
 then the identity value is the <code>MIN_VALUE</code>
 of the vector's native <code>ETYPE</code>.
 (In the case of floating point types, the value
 <code>NEGATIVE_INFINITY</code> is used, and will appear
 after casting as <code>Long.MIN_VALUE</code>.
 <li>
 If the operation is <code>MIN</code>,
 then the identity value is the <code>MAX_VALUE</code>
 of the vector's native <code>ETYPE</code>.
 (In the case of floating point types, the value
 <code>POSITIVE_INFINITY</code> is used, and will appear
 after casting as <code>Long.MAX_VALUE</code>.
 </ul>
 <p>
 In the case of operations <code>ADD</code> and <code>MUL</code>,
 when <code>ETYPE</code> is <code>float</code> or <code>double</code>,
 the precise result, before casting, will reflect the choice
 of an arbitrary order of operations, which may even vary over time.
 For further details see the section
 <a href="VectorOperators.html#fp_assoc">Operations on floating point vectors</a>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>If the <code>ETYPE</code> is <code>float</code> or <code>double</code>,
 this operation can lose precision and/or range, as a
 normal part of casting the result down to <code>long</code>.

 Usually
 <a href="IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)">strongly typed access</a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to combine lane values</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the reduced result accumulated from the selected lane values</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this vector does
         not support the requested operation</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#reduceLanesToLong(jdk.incubator.vector.VectorOperators.Associative)"><code>reduceLanesToLong(VectorOperators.Associative)</code></a></li>
<li><a href="IntVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)"><code>IntVector.reduceLanes(VectorOperators.Associative,VectorMask)</code></a></li>
<li><a href="FloatVector.html#reduceLanes(jdk.incubator.vector.VectorOperators.Associative,jdk.incubator.vector.VectorMask)"><code>FloatVector.reduceLanes(VectorOperators.Associative,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="test(jdk.incubator.vector.VectorOperators.Test)">
<h3>test</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">test</span><wbr><span class="parameters">(<a href="VectorOperators.Test.html" title="interface in jdk.incubator.vector">VectorOperators.Test</a>&nbsp;op)</span></div>
<div class="block">Tests the lanes of this vector
 according to the given operation.

 This is a lane-wise unary test operation which applies
 the given test operation
 to each lane value.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to test lane values</dd>
<dt>Returns:</dt>
<dd>the mask result of testing the lanes of this vector,
         according to the selected test operator</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector"><code>VectorOperators.Comparison</code></a></li>
<li><a href="#test(jdk.incubator.vector.VectorOperators.Test,jdk.incubator.vector.VectorMask)"><code>test(VectorOperators.Test, VectorMask)</code></a></li>
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison, Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="test(jdk.incubator.vector.VectorOperators.Test,jdk.incubator.vector.VectorMask)">
<h3>test</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">test</span><wbr><span class="parameters">(<a href="VectorOperators.Test.html" title="interface in jdk.incubator.vector">VectorOperators.Test</a>&nbsp;op,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Test selected lanes of this vector,
 according to the given operation.

 This is a masked lane-wise unary test operation which applies
 the given test operation
 to each lane value.

 The returned result is equal to the expression
 <code>test(op).and(m)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to test lane values</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the mask result of testing the lanes of this vector,
         according to the selected test operator,
         and only in the lanes selected by the mask</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#test(jdk.incubator.vector.VectorOperators.Test)"><code>test(VectorOperators.Test)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="eq(jdk.incubator.vector.Vector)">
<h3>eq</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">eq</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Tests if this vector is equal to another input vector.

 This is a lane-wise binary test operation which applies
 the primitive equals operation (<code>==</code>)
 to each pair of corresponding lane values.
 The result is the same as <code>compare(VectorOperators.EQ, v)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         equal to the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison,Vector)</code></a></li>
<li><a href="VectorOperators.html#EQ"><code>VectorOperators.EQ</code></a></li>
<li><a href="#equals(java.lang.Object)"><code>equals(java.lang.Object)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lt(jdk.incubator.vector.Vector)">
<h3>lt</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">lt</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Tests if this vector is less than another input vector.

 This is a lane-wise binary test operation which applies
 the primitive less-than operation (<code>&lt;</code>) to each lane.
 The result is the same as <code>compare(VectorOperators.LT, v)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         is less than the second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison,Vector)</code></a></li>
<li><a href="VectorOperators.html#LT"><code>VectorOperators.LT</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)">
<h3>compare</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">compare</span><wbr><span class="parameters">(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Tests this vector by comparing it with another input vector,
 according to the given comparison operation.

 This is a lane-wise binary test operation which applies
 the given comparison operation
 to each pair of corresponding lane values.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to compare lane values</dd>
<dd><code>v</code> - a second input vector</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         compares to the input, according to the selected
         comparison operator</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#eq(jdk.incubator.vector.Vector)"><code>eq(Vector)</code></a></li>
<li><a href="#lt(jdk.incubator.vector.Vector)"><code>lt(Vector)</code></a></li>
<li><a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector"><code>VectorOperators.Comparison</code></a></li>
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>compare(VectorOperators.Comparison, Vector, VectorMask)</code></a></li>
<li><a href="#test(jdk.incubator.vector.VectorOperators.Test)"><code>test(VectorOperators.Test)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>compare</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">compare</span><wbr><span class="parameters">(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Tests this vector by comparing it with another input vector,
 according to the given comparison operation,
 in lanes selected by a mask.

 This is a masked lane-wise binary test operation which applies
 the given comparison operation
 to each pair of corresponding lane values.

 The returned result is equal to the expression
 <code>compare(op,v).and(m)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to compare lane values</dd>
<dd><code>v</code> - a second input vector</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         compares to the input, according to the selected
         comparison operator,
         and only in the lanes selected by the mask</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison, Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compare(jdk.incubator.vector.VectorOperators.Comparison,long)">
<h3>compare</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">compare</span><wbr><span class="parameters">(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 long&nbsp;e)</span></div>
<div class="block">Tests this vector by comparing it with an input scalar,
 according to the given comparison operation.

 This is a lane-wise binary test operation which applies
 the given comparison operation
 to each lane value, paired with the broadcast value.

 <p>
 The result is the same as
 <code>this.compare(op, this.broadcast(e))</code>.
 That is, the scalar may be regarded as broadcast to
 a vector of the same species, and then compared
 against the original vector, using the selected
 comparison operation.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.  This rule is enforced
 by the implicit call to <code>broadcast()</code>.
 <p>
 Subtypes improve on this method by sharpening
 the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to compare lane values</dd>
<dd><code>e</code> - the input scalar</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         compares to the input, according to the selected
         comparison operator</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the given <code>long</code> value cannot
         be represented by the vector's <code>ETYPE</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#broadcast(long)"><code>broadcast(long)</code></a></li>
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compare(jdk.incubator.vector.VectorOperators.Comparison,long,jdk.incubator.vector.VectorMask)">
<h3>compare</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">compare</span><wbr><span class="parameters">(<a href="VectorOperators.Comparison.html" title="interface in jdk.incubator.vector">VectorOperators.Comparison</a>&nbsp;op,
 long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Tests this vector by comparing it with an input scalar,
 according to the given comparison operation,
 in lanes selected by a mask.

 This is a masked lane-wise binary test operation which applies
 the given comparison operation
 to each lane value, paired with the broadcast value.

 The returned result is equal to the expression
 <code>compare(op,e).and(m)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.  This rule is enforced
 by the implicit call to <code>broadcast()</code>.
 <p>
 Subtypes improve on this method by sharpening
 the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>op</code> - the operation used to compare lane values</dd>
<dd><code>e</code> - the input scalar</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Returns:</dt>
<dd>the mask result of testing lane-wise if this vector
         compares to the input, according to the selected
         comparison operator,
         and only in the lanes selected by the mask</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the given <code>long</code> value cannot
         be represented by the vector's <code>ETYPE</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#broadcast(long)"><code>broadcast(long)</code></a></li>
<li><a href="#compare(jdk.incubator.vector.VectorOperators.Comparison,jdk.incubator.vector.Vector)"><code>compare(VectorOperators.Comparison,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="blend(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>blend</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">blend</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Replaces selected lanes of this vector with
 corresponding lanes from a second input vector
 under the control of a mask.

 This is a masked lane-wise binary operation which
 selects each lane value from one or the other input.

 <ul>
 <li>
 For any lane <em>set</em> in the mask, the new lane value
 is taken from the second input vector, and replaces
 whatever value was in the that lane of this vector.
 <li>
 For any lane <em>unset</em> in the mask, the replacement is
 suppressed and this vector retains the original value stored in
 that lane.
 </ul>

 The following pseudocode illustrates this behavior:
 <pre><code>
 Vector&lt;E&gt; a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 Vector&lt;E&gt; b = ...;
 b.check(species);
 VectorMask&lt;E&gt; m = ...;
 ETYPE[] ar = a.toArray();
 for (int i = 0; i &lt; ar.length; i++) {
     if (m.laneIsSet(i)) {
         ar[i] = b.lane(i);
     }
 }
 return EVector.fromArray(s, ar, 0);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the second input vector, containing replacement lane values</dd>
<dd><code>m</code> - the mask controlling lane selection from the second input vector</dd>
<dt>Returns:</dt>
<dd>the result of blending the lane elements of this vector with
         those of the second input vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="blend(long,jdk.incubator.vector.VectorMask)">
<h3>blend</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">blend</span><wbr><span class="parameters">(long&nbsp;e,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Replaces selected lanes of this vector with
 a scalar value
 under the control of a mask.

 This is a masked lane-wise binary operation which
 selects each lane value from one or the other input.

 The returned result is equal to the expression
 <code>blend(broadcast(e),m)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.  This rule is enforced
 by the implicit call to <code>broadcast()</code>.
 <p>
 Subtypes improve on this method by sharpening
 the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>e</code> - the input scalar, containing the replacement lane value</dd>
<dd><code>m</code> - the mask controlling lane selection of the scalar</dd>
<dt>Returns:</dt>
<dd>the result of blending the lane elements of this vector with
         the scalar value</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="addIndex(int)">
<h3>addIndex</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">addIndex</span><wbr><span class="parameters">(int&nbsp;scale)</span></div>
<div class="block">Adds the lanes of this vector to their corresponding
 lane numbers, scaled by a given constant.

 This is a lane-wise unary operation which, for
 each lane <code>N</code>, computes the scaled index value
 <code>N*scale</code> and adds it to the value already
 in lane <code>N</code> of the current vector.

 <p> The scale must not be so large, and the element size must
 not be so small, that that there would be an overflow when
 computing any of the <code>N*scale</code> or <code>VLENGTH*scale</code>,
 when the result is represented using the vector
 lane type <code>ETYPE</code>.

 <p>
 The following pseudocode illustrates this behavior:
 <pre><code>
 Vector&lt;E&gt; a = ...;
 VectorSpecies&lt;E&gt; species = a.species();
 ETYPE[] ar = a.toArray();
 for (int i = 0; i &lt; ar.length; i++) {
     long d = (long)i * scale;
     if (d != (ETYPE) d)  throw ...;
     ar[i] += (ETYPE) d;
 }
 long d = (long)ar.length * scale;
 if (d != (ETYPE) d)  throw ...;
 return EVector.fromArray(s, ar, 0);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>scale</code> - the number to multiply by each lane index
        <code>N</code>, typically <code>1</code></dd>
<dt>Returns:</dt>
<dd>the result of incrementing each lane element by its
         corresponding lane index <code>N</code>, scaled by <code>scale</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the values in the interval
         <code>[0..VLENGTH*scale]</code>
         are not representable by the <code>ETYPE</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="slice(int,jdk.incubator.vector.Vector)">
<h3>slice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">slice</span><wbr><span class="parameters">(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1)</span></div>
<div class="block">Slices a segment of adjacent lanes, starting at a given
 <code>origin</code> lane in the current vector, and continuing (as
 needed) into an immediately following vector.  The block of
 <code>VLENGTH</code> lanes is extracted into its own vector and
 returned.

 <p> This is a cross-lane operation that shifts lane elements
 to the front, from the current vector and the second vector.
 Both vectors can be viewed as a combined "background" of length
 <code>2*VLENGTH</code>, from which a slice is extracted.

 The lane numbered <code>N</code> in the output vector is copied
 from lane <code>origin+N</code> of the input vector, if that
 lane exists, else from lane <code>origin+N-VLENGTH</code> of
 the second vector (which is guaranteed to exist).

 <p> The <code>origin</code> value must be in the inclusive range
 <code>0..VLENGTH</code>.  As limiting cases, <code>v.slice(0,w)</code>
 and <code>v.slice(VLENGTH,w)</code> return <code>v</code> and <code>w</code>,
 respectively.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This method may be regarded as the inverse of
 <a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice()</code></a>,
 in that the sliced value could be unsliced back into its
 original position in the two input vectors, without
 disturbing unrelated elements, as in the following
 pseudocode:
 <pre><code>
 EVector slice = v1.slice(origin, v2);
 EVector w1 = slice.unslice(origin, v1, 0);
 EVector w2 = slice.unslice(origin, v2, 1);
 assert v1.equals(w1);
 assert v2.equals(w2);
 </code></pre>

 <p> This method also supports a variety of cross-lane shifts and
 rotates as follows:
 <ul>

 <li>To shift lanes forward to the front of the vector, supply a
 zero vector for the second operand and specify the shift count
 as the origin.  For example: <code>v.slice(shift, v.broadcast(0))</code>.

 <li>To shift lanes backward to the back of the vector, supply a
 zero vector for the <em>first</em> operand, and specify the
 negative shift count as the origin (modulo <code>VLENGTH</code>.
 For example: <code>v.broadcast(0).slice(v.length()-shift, v)</code>.

 <li>To rotate lanes forward toward the front end of the vector,
 cycling the earliest lanes around to the back, supply the same
 vector for both operands and specify the rotate count as the
 origin.  For example: <code>v.slice(rotate, v)</code>.

 <li>To rotate lanes backward toward the back end of the vector,
 cycling the latest lanes around to the front, supply the same
 vector for both operands and specify the negative of the rotate
 count (modulo <code>VLENGTH</code>) as the origin.  For example:
 <code>v.slice(v.length() - rotate, v)</code>.

 <li>
 Since <code>origin</code> values less then zero or more than
 <code>VLENGTH</code> will be rejected, if you need to rotate
 by an unpredictable multiple of <code>VLENGTH</code>, be sure
 to reduce the origin value into the required range.
 The <a href="VectorSpecies.html#loopBound(int)"><code>loopBound()</code></a>
 method can help with this.  For example:
 <code>v.slice(rotate - v.species().loopBound(rotate), v)</code>.

 </ul></dd>
<dt>Parameters:</dt>
<dd><code>origin</code> - the first input lane to transfer into the slice</dd>
<dd><code>v1</code> - a second vector logically concatenated with the first,
        before the slice is taken (if omitted it defaults to zero)</dd>
<dt>Returns:</dt>
<dd>a contiguous slice of <code>VLENGTH</code> lanes, taken from
         this vector starting at the indicated origin, and
         continuing (as needed) into the second vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#slice(int,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)"><code>slice(int,Vector,VectorMask)</code></a></li>
<li><a href="#slice(int)"><code>slice(int)</code></a></li>
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice(int,Vector,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="slice(int,jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>slice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">slice</span><wbr><span class="parameters">(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v1,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Slices a segment of adjacent lanes
 under the control of a mask,
 starting at a given
 <code>origin</code> lane in the current vector, and continuing (as
 needed) into an immediately following vector.  The block of
 <code>VLENGTH</code> lanes is extracted into its own vector and
 returned.

 The resulting vector will be zero in all lanes unset in the
 given mask.  Lanes set in the mask will contain data copied
 from selected lanes of <code>this</code> or <code>v1</code>.

 <p> This is a cross-lane operation that shifts lane elements
 to the front, from the current vector and the second vector.
 Both vectors can be viewed as a combined "background" of length
 <code>2*VLENGTH</code>, from which a slice is extracted.

 The returned result is equal to the expression
 <code>broadcast(0).blend(slice(origin,v1),m)</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This method may be regarded as the inverse of
 <code>#unslice(int,Vector,int,VectorMask) unslice()</code>,
 in that the sliced value could be unsliced back into its
 original position in the two input vectors, without
 disturbing unrelated elements, as in the following
 pseudocode:
 <pre><code>
 EVector slice = v1.slice(origin, v2, m);
 EVector w1 = slice.unslice(origin, v1, 0, m);
 EVector w2 = slice.unslice(origin, v2, 1, m);
 assert v1.equals(w1);
 assert v2.equals(w2);
 </code></pre></dd>
<dt>Parameters:</dt>
<dd><code>origin</code> - the first input lane to transfer into the slice</dd>
<dd><code>v1</code> - a second vector logically concatenated with the first,
        before the slice is taken (if omitted it defaults to zero)</dd>
<dd><code>m</code> - the mask controlling lane selection into the resulting vector</dd>
<dt>Returns:</dt>
<dd>a contiguous slice of <code>VLENGTH</code> lanes, taken from
         this vector starting at the indicated origin, and
         continuing (as needed) into the second vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice(int,Vector)</code></a></li>
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)"><code>unslice(int,Vector,int,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="slice(int)">
<h3>slice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">slice</span><wbr><span class="parameters">(int&nbsp;origin)</span></div>
<div class="block">Slices a segment of adjacent lanes, starting at a given
 <code>origin</code> lane in the current vector.  A block of
 <code>VLENGTH</code> lanes, possibly padded with zero lanes, is
 extracted into its own vector and returned.

 This is a convenience method which slices from a single
 vector against an extended background of zero lanes.
 It is equivalent to
 <a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice</code></a><code>
 (origin, </code><a href="#broadcast(long)"><code>broadcast</code></a><code>(0))</code>.
 It may also be viewed simply as a cross-lane shift
 from later to earlier lanes, with zeroes filling
 in the vacated lanes at the end of the vector.
 In this view, the shift count is <code>origin</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origin</code> - the first input lane to transfer into the slice</dd>
<dt>Returns:</dt>
<dd>the last <code>VLENGTH-origin</code> input lanes,
         placed starting in the first lane of the output,
         padded at the end with zeroes</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice(int,Vector)</code></a></li>
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice(int,Vector,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="unslice(int,jdk.incubator.vector.Vector,int)">
<h3>unslice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">unslice</span><wbr><span class="parameters">(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;w,
 int&nbsp;part)</span></div>
<div class="block">Reverses a <a href="#slice(int,jdk.incubator.vector.Vector)">slice()</a>, inserting
 the current vector as a slice within another "background" input
 vector, which is regarded as one or the other input to a
 hypothetical subsequent <code>slice()</code> operation.

 <p> This is a cross-lane operation that permutes the lane
 elements of the current vector toward the back and inserts them
 into a logical pair of background vectors.  Only one of the
 pair will be returned, however.  The background is formed by
 duplicating the second input vector.  (However, the output will
 never contain two duplicates from the same input lane.)

 The lane numbered <code>N</code> in the input vector is copied into
 lane <code>origin+N</code> of the first background vector, if that
 lane exists, else into lane <code>origin+N-VLENGTH</code> of the
 second background vector (which is guaranteed to exist).

 The first or second background vector, updated with the
 inserted slice, is returned.  The <code>part</code> number of zero
 or one selects the first or second updated background vector.

 <p> The <code>origin</code> value must be in the inclusive range
 <code>0..VLENGTH</code>.  As limiting cases, <code>v.unslice(0,w,0)</code>
 and <code>v.unslice(VLENGTH,w,1)</code> both return <code>v</code>, while
 <code>v.unslice(0,w,1)</code> and <code>v.unslice(VLENGTH,w,0)</code>
 both return <code>w</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This method supports a variety of cross-lane insertion
 operations as follows:
 <ul>

 <li>To insert near the end of a background vector <code>w</code>
 at some offset, specify the offset as the origin and
 select part zero. For example: <code>v.unslice(offset, w, 0)</code>.

 <li>To insert near the end of a background vector <code>w</code>,
 but capturing the overflow into the next vector <code>x</code>,
 specify the offset as the origin and select part one.
 For example: <code>v.unslice(offset, x, 1)</code>.

 <li>To insert the last <code>N</code> items near the beginning
 of a background vector <code>w</code>, supply a <code>VLENGTH-N</code>
 as the origin and select part one.
 For example: <code>v.unslice(v.length()-N, w)</code>.

 </ul></dd>
<dt>Parameters:</dt>
<dd><code>origin</code> - the first output lane to receive the slice</dd>
<dd><code>w</code> - the background vector that (as two copies) will receive
        the inserted slice</dd>
<dd><code>part</code> - the part number of the result (either zero or one)</dd>
<dt>Returns:</dt>
<dd>either the first or second part of a pair of
         background vectors <code>w</code>, updated by inserting
         this vector at the indicated origin</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code>,
         or if <code>part</code> is not zero or one</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice(int,Vector)</code></a></li>
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)"><code>unslice(int,Vector,int,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="unslice(int,jdk.incubator.vector.Vector,int,jdk.incubator.vector.VectorMask)">
<h3>unslice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">unslice</span><wbr><span class="parameters">(int&nbsp;origin,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;w,
 int&nbsp;part,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Reverses a <a href="#slice(int,jdk.incubator.vector.Vector)">slice()</a>, inserting
 (under the control of a mask)
 the current vector as a slice within another "background" input
 vector, which is regarded as one or the other input to a
 hypothetical subsequent <code>slice()</code> operation.

 <p> This is a cross-lane operation that permutes the lane
 elements of the current vector forward and inserts its lanes
 (when selected by the mask) into a logical pair of background
 vectors.  As with the
 <a href="#unslice(int,jdk.incubator.vector.Vector,int)">unmasked version</a> of this method,
 only one of the pair will be returned, as selected by the
 <code>part</code> number.

 For each lane <code>N</code> selected by the mask, the lane value
 is copied into
 lane <code>origin+N</code> of the first background vector, if that
 lane exists, else into lane <code>origin+N-VLENGTH</code> of the
 second background vector (which is guaranteed to exist).
 Background lanes retain their original values if the
 corresponding input lanes <code>N</code> are unset in the mask.

 The first or second background vector, updated with set lanes
 of the inserted slice, is returned.  The <code>part</code> number of
 zero or one selects the first or second updated background
 vector.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origin</code> - the first output lane to receive the slice</dd>
<dd><code>w</code> - the background vector that (as two copies) will receive
        the inserted slice, if they are set in <code>m</code></dd>
<dd><code>part</code> - the part number of the result (either zero or one)</dd>
<dd><code>m</code> - the mask controlling lane selection from the current vector</dd>
<dt>Returns:</dt>
<dd>either the first or second part of a pair of
         background vectors <code>w</code>, updated by inserting
         selected lanes of this vector at the indicated origin</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code>,
         or if <code>part</code> is not zero or one</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice(int,Vector,int)</code></a></li>
<li><a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice(int,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="unslice(int)">
<h3>unslice</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">unslice</span><wbr><span class="parameters">(int&nbsp;origin)</span></div>
<div class="block">Reverses a <a href="#slice(int)">slice()</a>, inserting
 the current vector as a slice within a "background" input
 of zero lane values.  Compared to other <code>unslice()</code>
 methods, this method only returns the first of the
 pair of background vectors.

 This is a convenience method which returns the result of
 <a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice</code></a><code>
 (origin, </code><a href="#broadcast(long)"><code>broadcast</code></a><code>(0), 0)</code>.
 It may also be viewed simply as a cross-lane shift
 from earlier to later lanes, with zeroes filling
 in the vacated lanes at the beginning of the vector.
 In this view, the shift count is <code>origin</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>origin</code> - the first output lane to receive the slice</dd>
<dt>Returns:</dt>
<dd>the first <code>VLENGTH-origin</code> input lanes,
         placed starting at the given origin,
         padded at the beginning with zeroes</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - if <code>origin</code>
         is negative or greater than <code>VLENGTH</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#unslice(int,jdk.incubator.vector.Vector,int)"><code>unslice(int,Vector,int)</code></a></li>
<li><a href="#slice(int)"><code>slice(int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rearrange(jdk.incubator.vector.VectorShuffle)">
<h3>rearrange</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">rearrange</span><wbr><span class="parameters">(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s)</span></div>
<div class="block">Rearranges the lane elements of this vector, selecting lanes
 under the control of a specific shuffle.

 This is a cross-lane operation that rearranges the lane
 elements of this vector.

 For each lane <code>N</code> of the shuffle, and for each lane
 source index <code>I=s.laneSource(N)</code> in the shuffle,
 the output lane <code>N</code> obtains the value from
 the input vector at lane <code>I</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>s</code> - the shuffle controlling lane index selection</dd>
<dt>Returns:</dt>
<dd>the rearrangement of the lane elements of this vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if there are any exceptional
        source indexes in the shuffle</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)"><code>rearrange(VectorShuffle,VectorMask)</code></a></li>
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)"><code>rearrange(VectorShuffle,Vector)</code></a></li>
<li><a href="VectorShuffle.html#laneIsValid()"><code>VectorShuffle.laneIsValid()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)">
<h3>rearrange</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">rearrange</span><wbr><span class="parameters">(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Rearranges the lane elements of this vector, selecting lanes
 under the control of a specific shuffle and a mask.

 This is a cross-lane operation that rearranges the lane
 elements of this vector.

 For each lane <code>N</code> of the shuffle, and for each lane
 source index <code>I=s.laneSource(N)</code> in the shuffle,
 the output lane <code>N</code> obtains the value from
 the input vector at lane <code>I</code> if the mask is set.
 Otherwise the output lane <code>N</code> is set to zero.

 <p> This method returns the value of this pseudocode:
 <pre><code>
 Vector&lt;E&gt; r = this.rearrange(s.wrapIndexes());
 VectorMask&lt;E&gt; valid = s.laneIsValid();
 if (m.andNot(valid).anyTrue()) throw ...;
 return broadcast(0).blend(r, m);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>s</code> - the shuffle controlling lane index selection</dd>
<dd><code>m</code> - the mask controlling application of the shuffle</dd>
<dt>Returns:</dt>
<dd>the rearrangement of the lane elements of this vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if there are any exceptional
        source indexes in the shuffle where the mask is set</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle)"><code>rearrange(VectorShuffle)</code></a></li>
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)"><code>rearrange(VectorShuffle,Vector)</code></a></li>
<li><a href="VectorShuffle.html#laneIsValid()"><code>VectorShuffle.laneIsValid()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.Vector)">
<h3>rearrange</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">rearrange</span><wbr><span class="parameters">(<a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;s,
 <a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Rearranges the lane elements of two vectors, selecting lanes
 under the control of a specific shuffle, using both normal and
 exceptional indexes in the shuffle to steer data.

 This is a cross-lane operation that rearranges the lane
 elements of the two input vectors (the current vector
 and a second vector <code>v</code>).

 For each lane <code>N</code> of the shuffle, and for each lane
 source index <code>I=s.laneSource(N)</code> in the shuffle,
 the output lane <code>N</code> obtains the value from
 the first vector at lane <code>I</code> if <code>I&gt;=0</code>.
 Otherwise, the exceptional index <code>I</code> is wrapped
 by adding <code>VLENGTH</code> to it and used to index
 the <em>second</em> vector, at index <code>I+VLENGTH</code>.

 <p> This method returns the value of this pseudocode:
 <pre><code>
 Vector&lt;E&gt; r1 = this.rearrange(s.wrapIndexes());
 // or else: r1 = this.rearrange(s, s.laneIsValid());
 Vector&lt;E&gt; r2 = v.rearrange(s.wrapIndexes());
 return r2.blend(r1,s.laneIsValid());
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>s</code> - the shuffle controlling lane selection from both input vectors</dd>
<dd><code>v</code> - the second input vector</dd>
<dt>Returns:</dt>
<dd>the rearrangement of lane elements of this vector and
         a second input vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle)"><code>rearrange(VectorShuffle)</code></a></li>
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)"><code>rearrange(VectorShuffle,VectorMask)</code></a></li>
<li><a href="VectorShuffle.html#laneIsValid()"><code>VectorShuffle.laneIsValid()</code></a></li>
<li><a href="#slice(int,jdk.incubator.vector.Vector)"><code>slice(int,Vector)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="compress(jdk.incubator.vector.VectorMask)">
<h3>compress</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">compress</span><wbr><span class="parameters">(<a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Compresses the lane elements of this vector selecting lanes
 under the control of a specific mask.

 This is a cross-lane operation that compresses the lane
 elements of this vector as selected by the specified mask.

 For each lane <code>N</code> of the mask, if the mask at
 lane <code>N</code> is set, the element at lane <code>N</code>
 of input vector is selected and stored into the output
 vector contiguously starting from the lane <code>0</code>.
 All the upper remaining lanes, if any, of the output
 vector are set to zero.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - the mask controlling the compression</dd>
<dt>Returns:</dt>
<dd>the compressed lane elements of this vector</dd>
<dt>Since:</dt>
<dd>19</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="expand(jdk.incubator.vector.VectorMask)">
<h3>expand</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">expand</span><wbr><span class="parameters">(<a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Expands the lane elements of this vector
 under the control of a specific mask.

 This is a cross-lane operation that expands the contiguous lane
 elements of this vector into lanes of an output vector
 as selected by the specified mask.

 For each lane <code>N</code> of the mask, if the mask at
 lane <code>N</code> is set, the next contiguous element of input vector
 starting from lane <code>0</code> is selected and stored into the output
 vector at lane <code>N</code>.
 All the remaining lanes, if any, of the output vector are set to zero.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>m</code> - the mask controlling the compression</dd>
<dt>Returns:</dt>
<dd>the expanded lane elements of this vector</dd>
<dt>Since:</dt>
<dd>19</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="selectFrom(jdk.incubator.vector.Vector)">
<h3>selectFrom</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">selectFrom</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v)</span></div>
<div class="block">Using index values stored in the lanes of this vector,
 assemble values stored in second vector <code>v</code>.
 The second vector thus serves as a table, whose
 elements are selected by indexes in the current vector.

 This is a cross-lane operation that rearranges the lane
 elements of the argument vector, under the control of
 this vector.

 For each lane <code>N</code> of this vector, and for each lane
 value <code>I=this.lane(N)</code> in this vector,
 the output lane <code>N</code> obtains the value from
 the argument vector at lane <code>I</code>.

 In this way, the result contains only values stored in the
 argument vector <code>v</code>, but presented in an order which
 depends on the index values in <code>this</code>.

 The result is the same as the expression
 <code>v.rearrange(this.toShuffle())</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the vector supplying the result values</dd>
<dt>Returns:</dt>
<dd>the rearrangement of the lane elements of <code>v</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if any invalid
         source indexes are found in <code>this</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle)"><code>rearrange(VectorShuffle)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="selectFrom(jdk.incubator.vector.Vector,jdk.incubator.vector.VectorMask)">
<h3>selectFrom</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">selectFrom</span><wbr><span class="parameters">(<a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;v,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Using index values stored in the lanes of this vector,
 assemble values stored in second vector, under the control
 of a mask.
 Using index values stored in the lanes of this vector,
 assemble values stored in second vector <code>v</code>.
 The second vector thus serves as a table, whose
 elements are selected by indexes in the current vector.
 Lanes that are unset in the mask receive a
 zero rather than a value from the table.

 This is a cross-lane operation that rearranges the lane
 elements of the argument vector, under the control of
 this vector and the mask.

 The result is the same as the expression
 <code>v.rearrange(this.toShuffle(), m)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>v</code> - the vector supplying the result values</dd>
<dd><code>m</code> - the mask controlling selection from <code>v</code></dd>
<dt>Returns:</dt>
<dd>the rearrangement of the lane elements of <code>v</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if any invalid
         source indexes are found in <code>this</code>,
         in a lane which is set in the mask</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#selectFrom(jdk.incubator.vector.Vector)"><code>selectFrom(Vector)</code></a></li>
<li><a href="#rearrange(jdk.incubator.vector.VectorShuffle,jdk.incubator.vector.VectorMask)"><code>rearrange(VectorShuffle,VectorMask)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="broadcast(long)">
<h3>broadcast</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">broadcast</span><wbr><span class="parameters">(long&nbsp;e)</span></div>
<div class="block">Returns a vector of the same species as this one
 where all lane elements are set to
 the primitive value <code>e</code>.

 The contents of the current vector are discarded;
 only the species is relevant to this operation.

 <p> This method returns the value of this expression:
 <code>EVector.broadcast(this.species(), (ETYPE)e)</code>, where
 <code>EVector</code> is the vector class specific to this
 vector's element type <code>ETYPE</code>.

 <p>
 The <code>long</code> value <code>e</code> must be accurately
 representable by the <code>ETYPE</code> of this vector's species,
 so that <code>e==(long)(ETYPE)e</code>.

 If this rule is violated the problem is not detected
 statically, but an <code>IllegalArgumentException</code> is thrown
 at run-time.  Thus, this method somewhat weakens the static
 type checking of immediate constants and other scalars, but it
 makes up for this by improving the expressiveness of the
 generic API.  Note that an <code>e</code> value in the range
 <code>[-128..127]</code> is always acceptable, since every
 <code>ETYPE</code> will accept every <code>byte</code> value.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the method return type and
 and the type of the scalar parameter <code>e</code>.</dd>
<dt>Parameters:</dt>
<dd><code>e</code> - the value to broadcast</dd>
<dt>Returns:</dt>
<dd>a vector where all lane elements are set to
         the primitive value <code>e</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the given <code>long</code> value cannot
         be represented by the vector's <code>ETYPE</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="VectorSpecies.html#broadcast(long)"><code>VectorSpecies.broadcast(long)</code></a></li>
<li><a href="IntVector.html#broadcast(int)"><code>IntVector.broadcast(int)</code></a></li>
<li><a href="FloatVector.html#broadcast(float)"><code>FloatVector.broadcast(float)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="maskAll(boolean)">
<h3>maskAll</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">maskAll</span><wbr><span class="parameters">(boolean&nbsp;bit)</span></div>
<div class="block">Returns a mask of same species as this vector,
 where each lane is set or unset according to given
 single boolean, which is broadcast to all lanes.
 <p>
 This method returns the value of this expression:
 <code>species().maskAll(bit)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>bit</code> - the given mask bit to be replicated</dd>
<dt>Returns:</dt>
<dd>a mask where each lane is set or unset according to
         the given bit</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="VectorSpecies.html#maskAll(boolean)"><code>VectorSpecies.maskAll(boolean)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toShuffle()">
<h3>toShuffle</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="VectorShuffle.html" title="class in jdk.incubator.vector">VectorShuffle</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;</span>&nbsp;<span class="element-name">toShuffle</span>()</div>
<div class="block">Converts this vector into a shuffle, converting the lane values
 to <code>int</code> and regarding them as source indexes.
 <p>
 This method behaves as if it returns the result of creating a shuffle
 given an array of the vector elements, as follows:
 <pre><code>
 long[] a = this.toLongArray();
 int[] sa = new int[a.length];
 for (int i = 0; i &lt; a.length; i++) {
     sa[i] = (int) a[i];
 }
 return VectorShuffle.fromValues(this.species(), sa);
 </code></pre></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a shuffle representation of this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorShuffle.html#fromValues(jdk.incubator.vector.VectorSpecies,int...)"><code>VectorShuffle.fromValues(VectorSpecies,int...)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretShape(jdk.incubator.vector.VectorSpecies,int)">
<h3>reinterpretShape</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">reinterpretShape</span><wbr><span class="parameters">(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;species,
 int&nbsp;part)</span></div>
<div class="block">Transforms this vector to a vector of the given species of
 element type <code>F</code>, reinterpreting the bytes of this
 vector without performing any value conversions.

 <p> Depending on the selected species, this operation may
 either <a href="Vector.html#expansion">expand or contract</a>
 its logical result, in which case a non-zero <code>part</code>
 number can further control the selection and steering of the
 logical result into the physical output vector.

 <p>
 The underlying bits of this vector are copied to the resulting
 vector without modification, but those bits, before copying,
 may be truncated if the this vector's bit-size is greater than
 desired vector's bit size, or filled with zero bits if this
 vector's bit-size is less than desired vector's bit-size.

 <p> If the old and new species have different shape, this is a
 <em>shape-changing</em> operation, and may have special
 implementation costs.

 <p> The method behaves as if this vector is stored into a byte
 array using little-endian byte ordering and then the desired vector is loaded from the same byte
 array using the same ordering.

 <p> The following pseudocode illustrates the behavior:
 <pre><code>
 int domSize = this.byteSize();
 int ranSize = species.vectorByteSize();
 int M = (domSize &gt; ranSize ? domSize / ranSize : ranSize / domSize);
 assert Math.abs(part) &lt; M;
 assert (part == 0) || (part &gt; 0) == (domSize &gt; ranSize);
 MemorySegment ms = MemorySegment.ofArray(new byte[Math.max(domSize, ranSize)]);
 if (domSize &gt; ranSize) {  // expansion
     this.intoMemorySegment(ms, 0, ByteOrder.native());
     int origin = part * ranSize;
     return species.fromMemorySegment(ms, origin, ByteOrder.native());
 } else {  // contraction or size-invariant
     int origin = (-part) * domSize;
     this.intoMemorySegment(ms, origin, ByteOrder.native());
     return species.fromMemorySegment(ms, 0, ByteOrder.native());
 }
 </code></pre></div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Although this method is defined as if the vectors in
 question were loaded or stored into memory, memory semantics
 has little to do or nothing with the actual implementation.
 The appeal to little-endian ordering is simply a shorthand
 for what could otherwise be a large number of detailed rules
 concerning the mapping between lane-structured vectors and
 byte-structured vectors.</dd>
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the species</dd>
<dt>Parameters:</dt>
<dd><code>species</code> - the desired vector species</dd>
<dd><code>part</code> - the <a href="Vector.html#expansion">part number</a>
        of the result, or zero if neither expanding nor contracting</dd>
<dt>Returns:</dt>
<dd>a vector transformed, by shape and element type, from this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)"><code>convertShape(VectorOperators.Conversion,VectorSpecies,int)</code></a></li>
<li><a href="#castShape(jdk.incubator.vector.VectorSpecies,int)"><code>castShape(VectorSpecies,int)</code></a></li>
<li><a href="VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)"><code>VectorSpecies.partLimit(VectorSpecies,boolean)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsBytes()">
<h3>reinterpretAsBytes</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="ByteVector.html" title="class in jdk.incubator.vector">ByteVector</a></span>&nbsp;<span class="element-name">reinterpretAsBytes</span>()</div>
<div class="block">Views this vector as a vector of the same shape
 and contents but a lane type of <code>byte</code>,
 where the bytes are extracted from the lanes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(byte.class))</code>.
 It may be considered an inverse to the various
 methods which consolidate bytes into larger lanes
 within the same vector, such as
 <a href="#reinterpretAsInts()"><code>reinterpretAsInts()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>ByteVector</code> with the same shape and information content</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)"><code>reinterpretShape(VectorSpecies,int)</code></a></li>
<li><a href="IntVector.html#intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)"><code>IntVector.intoMemorySegment(java.lang.foreign.MemorySegment, long, java.nio.ByteOrder)</code></a><sup><a href="IntVector.html#preview-intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)">PREVIEW</a></sup></li>
<li><a href="FloatVector.html#intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)"><code>FloatVector.intoMemorySegment(java.lang.foreign.MemorySegment, long, java.nio.ByteOrder)</code></a><sup><a href="FloatVector.html#preview-intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)">PREVIEW</a></sup></li>
<li><a href="VectorSpecies.html#withLanes(java.lang.Class)"><code>VectorSpecies.withLanes(Class)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsShorts()">
<h3>reinterpretAsShorts</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="ShortVector.html" title="class in jdk.incubator.vector">ShortVector</a></span>&nbsp;<span class="element-name">reinterpretAsShorts</span>()</div>
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>short</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(short.class))</code>.
 It may be considered an inverse to <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>ShortVector</code> with the same shape and information content</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsInts()">
<h3>reinterpretAsInts</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="IntVector.html" title="class in jdk.incubator.vector">IntVector</a></span>&nbsp;<span class="element-name">reinterpretAsInts</span>()</div>
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>int</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(int.class))</code>.
 It may be considered an inverse to <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>IntVector</code> with the same shape and information content</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsLongs()">
<h3>reinterpretAsLongs</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="LongVector.html" title="class in jdk.incubator.vector">LongVector</a></span>&nbsp;<span class="element-name">reinterpretAsLongs</span>()</div>
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>long</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(long.class))</code>.
 It may be considered an inverse to <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>LongVector</code> with the same shape and information content</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsFloats()">
<h3>reinterpretAsFloats</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="FloatVector.html" title="class in jdk.incubator.vector">FloatVector</a></span>&nbsp;<span class="element-name">reinterpretAsFloats</span>()</div>
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>float</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(float.class))</code>.
 It may be considered an inverse to <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>FloatVector</code> with the same shape and information content</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reinterpretAsDoubles()">
<h3>reinterpretAsDoubles</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="DoubleVector.html" title="class in jdk.incubator.vector">DoubleVector</a></span>&nbsp;<span class="element-name">reinterpretAsDoubles</span>()</div>
<div class="block">Reinterprets this vector as a vector of the same shape
 and contents but a lane type of <code>double</code>,
 where the lanes are assembled from successive bytes
 according to little-endian order.
 It is a convenience method for the expression
 <code>reinterpretShape(species().withLanes(double.class))</code>.
 It may be considered an inverse to <a href="#reinterpretAsBytes()"><code>reinterpretAsBytes()</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <code>DoubleVector</code> with the same shape and information content</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="viewAsIntegralLanes()">
<h3>viewAsIntegralLanes</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;?&gt;</span>&nbsp;<span class="element-name">viewAsIntegralLanes</span>()</div>
<div class="block">Views this vector as a vector of the same shape, length, and
 contents, but a lane type that is not a floating-point type.

 This is a lane-wise reinterpretation cast on the lane values.
 As such, this method does not change <code>VSHAPE</code> or
 <code>VLENGTH</code>, and there is no change to the bitwise contents
 of the vector.  If the vector's <code>ETYPE</code> is already an
 integral type, the same vector is returned unchanged.

 This method returns the value of this expression:
 <code>convert(conv,0)</code>, where <code>conv</code> is
 <code>VectorOperators.Conversion.ofReinterpret(E.class,F.class)</code>,
 and <code>F</code> is the non-floating-point type of the
 same size as <code>E</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the return type.</dd>
<dt>Returns:</dt>
<dd>the original vector, reinterpreted as non-floating point</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.Conversion.html#ofReinterpret(java.lang.Class,java.lang.Class)"><code>VectorOperators.Conversion.ofReinterpret(Class,Class)</code></a></li>
<li><a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>convert(VectorOperators.Conversion,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="viewAsFloatingLanes()">
<h3>viewAsFloatingLanes</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;?&gt;</span>&nbsp;<span class="element-name">viewAsFloatingLanes</span>()</div>
<div class="block">Views this vector as a vector of the same shape, length, and
 contents, but a lane type that is a floating-point type.

 This is a lane-wise reinterpretation cast on the lane values.
 As such, there this method does not change <code>VSHAPE</code> or
 <code>VLENGTH</code>, and there is no change to the bitwise contents
 of the vector.  If the vector's <code>ETYPE</code> is already a
 float-point type, the same vector is returned unchanged.

 If the vector's element size does not match any floating point
 type size, an <code>IllegalArgumentException</code> is thrown.

 This method returns the value of this expression:
 <code>convert(conv,0)</code>, where <code>conv</code> is
 <code>VectorOperators.Conversion.ofReinterpret(E.class,F.class)</code>,
 and <code>F</code> is the floating-point type of the
 same size as <code>E</code>, if any.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Subtypes improve on this method by sharpening
 the return type.</dd>
<dt>Returns:</dt>
<dd>the original vector, reinterpreted as floating point</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if there is no floating point
         type the same size as the lanes of this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.Conversion.html#ofReinterpret(java.lang.Class,java.lang.Class)"><code>VectorOperators.Conversion.ofReinterpret(Class,Class)</code></a></li>
<li><a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>convert(VectorOperators.Conversion,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convert(jdk.incubator.vector.VectorOperators.Conversion,int)">
<h3>convert</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">convert</span><wbr><span class="parameters">(<a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">VectorOperators.Conversion</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>,<wbr>F&gt;&nbsp;conv,
 int&nbsp;part)</span></div>
<div class="block">Convert this vector to a vector of the same shape and a new
 element type, converting lane values from the current <code>ETYPE</code>
 to a new lane type (called <code>FTYPE</code> here) according to the
 indicated <a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">conversion</a>.

 This is a lane-wise shape-invariant operation which copies
 <code>ETYPE</code> values from the input vector to corresponding
 <code>FTYPE</code> values in the result.  Depending on the selected
 conversion, this operation may either
 <a href="Vector.html#expansion">expand or contract</a> its
 logical result, in which case a non-zero <code>part</code> number
 can further control the selection and steering of the logical
 result into the physical output vector.

 <p> Each specific conversion is described by a conversion
 constant in the class <a href="VectorOperators.html" title="class in jdk.incubator.vector"><code>VectorOperators</code></a>.  Each conversion
 operator has a specified <a href="VectorOperators.Conversion.html#domainType()">domain type</a> and
 <a href="VectorOperators.Conversion.html#rangeType()">range type</a>.
 The domain type must exactly match the lane type of the input
 vector, while the range type determines the lane type of the
 output vectors.

 <p> A conversion operator may be classified as (respectively)
 in-place, expanding, or contracting, depending on whether the
 bit-size of its domain type is (respectively) equal, less than,
 or greater than the bit-size of its range type.

 <p> Independently, conversion operations can also be classified
 as reinterpreting or value-transforming, depending on whether
 the conversion copies representation bits unchanged, or changes
 the representation bits in order to retain (part or all of)
 the logical value of the input value.

 <p> If a reinterpreting conversion contracts, it will truncate the
 upper bits of the input.  If it expands, it will pad upper bits
 of the output with zero bits, when there are no corresponding
 input bits.

 <p> An expanding conversion such as <code>S2I</code> (<code>short</code>
 value to <code>int</code>) takes a scalar value and represents it
 in a larger format (always with some information redundancy).

 A contracting conversion such as <code>D2F</code> (<code>double</code>
 value to <code>float</code>) takes a scalar value and represents it
 in a smaller format (always with some information loss).

 Some in-place conversions may also include information loss,
 such as <code>L2D</code> (<code>long</code> value to <code>double</code>)
 or <code>F2I</code>  (<code>float</code> value to <code>int</code>).

 Reinterpreting in-place conversions are not lossy, unless the
 bitwise value is somehow not legal in the output type.
 Converting the bit-pattern of a <code>NaN</code> may discard bits
 from the <code>NaN</code>'s significand.

 <p> This classification is important, because, unless otherwise
 documented, conversion operations <em>never change vector
 shape</em>, regardless of how they may change <em>lane sizes</em>.

 Therefore an <em>expanding</em> conversion cannot store all of its
 results in its output vector, because the output vector has fewer
 lanes of larger size, in order to have the same overall bit-size as
 its input.

 Likewise, a contracting conversion must store its relatively small
 results into a subset of the lanes of the output vector, defaulting
 the unused lanes to zero.

 <p> As an example, a conversion from <code>byte</code> to <code>long</code>
 (<code>M=8</code>) will discard 87.5% of the input values in order to
 convert the remaining 12.5% into the roomy <code>long</code> lanes of
 the output vector. The inverse conversion will convert back all of
 the large results, but will waste 87.5% of the lanes in the output
 vector.

 <em>In-place</em> conversions (<code>M=1</code>) deliver all of
 their results in one output vector, without wasting lanes.

 <p> To manage the details of these
 <a href="Vector.html#expansion">expansions and contractions</a>,
 a non-zero <code>part</code> parameter selects partial results from
 expansions, or steers the results of contractions into
 corresponding locations, as follows:

 <ul>
 <li> expanding by <code>M</code>: <code>part</code> must be in the range
 <code>[0..M-1]</code>, and selects the block of <code>VLENGTH/M</code> input
 lanes starting at the <em>origin lane</em> at <code>part*VLENGTH/M</code>.

 <p> The <code>VLENGTH/M</code> output lanes represent a partial
 slice of the whole logical result of the conversion, filling
 the entire physical output vector.

 <li> contracting by <code>M</code>: <code>part</code> must be in the range
 <code>[-M+1..0]</code>, and steers all <code>VLENGTH</code> input lanes into
 the output located at the <em>origin lane</em> <code>-part*VLENGTH</code>.
 There is a total of <code>VLENGTH*M</code> output lanes, and those not
 holding converted input values are filled with zeroes.

 <p> A group of such output vectors, with logical result parts
 steered to disjoint blocks, can be reassembled using the
 <a href="VectorOperators.html#OR">bitwise or</a> or (for floating
 point) the <a href="VectorOperators.html#FIRST_NONZERO"><code>FIRST_NONZERO</code></a>
 operator.

 <li> in-place (<code>M=1</code>): <code>part</code> must be zero.
 Both vectors have the same <code>VLENGTH</code>.  The result is
 always positioned at the <em>origin lane</em> of zero.

 </ul>

 <p> This method is a restricted version of the more general
 but less frequently used <em>shape-changing</em> method
 <a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)"><code>convertShape()</code></a>.
 The result of this method is the same as the expression
 <code>this.convertShape(conv, rsp, this.broadcast(part))</code>,
 where the output species is
 <code>rsp=this.species().withLanes(FTYPE.class)</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the species</dd>
<dt>Parameters:</dt>
<dd><code>conv</code> - the desired scalar conversion to apply lane-wise</dd>
<dd><code>part</code> - the <a href="Vector.html#expansion">part number</a>
        of the result, or zero if neither expanding nor contracting</dd>
<dt>Returns:</dt>
<dd>a vector converted by shape and element type from this vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</a></code> - unless <code>part</code> is zero,
         or else the expansion ratio is <code>M</code> and
         <code>part</code> is positive and less than <code>M</code>,
         or else the contraction ratio is <code>M</code> and
         <code>part</code> is negative and greater <code>-M</code></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.html#I2L"><code>VectorOperators.I2L</code></a></li>
<li><a href="VectorOperators.Conversion.html#ofCast(java.lang.Class,java.lang.Class)"><code>VectorOperators.Conversion.ofCast(Class,Class)</code></a></li>
<li><a href="VectorSpecies.html#partLimit(jdk.incubator.vector.VectorSpecies,boolean)"><code>VectorSpecies.partLimit(VectorSpecies,boolean)</code></a></li>
<li><a href="#viewAsFloatingLanes()"><code>viewAsFloatingLanes()</code></a></li>
<li><a href="#viewAsIntegralLanes()"><code>viewAsIntegralLanes()</code></a></li>
<li><a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)"><code>convertShape(VectorOperators.Conversion,VectorSpecies,int)</code></a></li>
<li><a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)"><code>reinterpretShape(VectorSpecies,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)">
<h3>convertShape</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">convertShape</span><wbr><span class="parameters">(<a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">VectorOperators.Conversion</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>,<wbr>F&gt;&nbsp;conv,
 <a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;rsp,
 int&nbsp;part)</span></div>
<div class="block">Converts this vector to a vector of the given species, shape and
 element type, converting lane values from the current <code>ETYPE</code>
 to a new lane type (called <code>FTYPE</code> here) according to the
 indicated <a href="VectorOperators.Conversion.html" title="interface in jdk.incubator.vector">conversion</a>.

 This is a lane-wise operation which copies <code>ETYPE</code> values
 from the input vector to corresponding <code>FTYPE</code> values in
 the result.

 <p> If the old and new species have the same shape, the behavior
 is exactly the same as the simpler, shape-invariant method
 <a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>convert()</code></a>.
 In such cases, the simpler method <code>convert()</code> should be
 used, to make code easier to reason about.
 Otherwise, this is a <em>shape-changing</em> operation, and may
 have special implementation costs.

 <p> As a combined effect of shape changes and lane size changes,
 the input and output species may have different lane counts, causing
 <a href="Vector.html#expansion">expansion or contraction</a>.
 In this case a non-zero <code>part</code> parameter selects
 partial results from an expanded logical result, or steers
 the results of a contracted logical result into a physical
 output vector of the required output species.

 <p>The following pseudocode illustrates the behavior of this
 method for in-place, expanding, and contracting conversions.
 (This pseudocode also applies to the shape-invariant method,
 but with shape restrictions on the output species.)
 Note that only one of the three code paths is relevant to any
 particular combination of conversion operator and shapes.

 <pre><code>
 FTYPE scalar_conversion_op(ETYPE s);
 EVector a = ...;
 VectorSpecies&lt;F&gt; rsp = ...;
 int part = ...;
 VectorSpecies&lt;E&gt; dsp = a.species();
 int domlen = dsp.length();
 int ranlen = rsp.length();
 FTYPE[] logical = new FTYPE[domlen];
 for (int i = 0; i &lt; domlen; i++) {
   logical[i] = scalar_conversion_op(a.lane(i));
 }
 FTYPE[] physical;
 if (domlen == ranlen) { // in-place
     assert part == 0; //else AIOOBE
     physical = logical;
 } else if (domlen &gt; ranlen) { // expanding
     int M = domlen / ranlen;
     assert 0 &lt;= part &amp;&amp; part &lt; M; //else AIOOBE
     int origin = part * ranlen;
     physical = Arrays.copyOfRange(logical, origin, origin + ranlen);
 } else { // (domlen &lt; ranlen) // contracting
     int M = ranlen / domlen;
     assert 0 &gt;= part &amp;&amp; part &gt; -M; //else AIOOBE
     int origin = -part * domlen;
     System.arraycopy(logical, 0, physical, origin, domlen);
 }
 return FVector.fromArray(ran, physical, 0);
 </code></pre></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the output species</dd>
<dt>Parameters:</dt>
<dd><code>conv</code> - the desired scalar conversion to apply lane-wise</dd>
<dd><code>rsp</code> - the desired output species</dd>
<dd><code>part</code> - the <a href="Vector.html#expansion">part number</a>
        of the result, or zero if neither expanding nor contracting</dd>
<dt>Returns:</dt>
<dd>a vector converted by element type from this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#convert(jdk.incubator.vector.VectorOperators.Conversion,int)"><code>convert(VectorOperators.Conversion,int)</code></a></li>
<li><a href="#castShape(jdk.incubator.vector.VectorSpecies,int)"><code>castShape(VectorSpecies,int)</code></a></li>
<li><a href="#reinterpretShape(jdk.incubator.vector.VectorSpecies,int)"><code>reinterpretShape(VectorSpecies,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="castShape(jdk.incubator.vector.VectorSpecies,int)">
<h3>castShape</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">castShape</span><wbr><span class="parameters">(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;rsp,
 int&nbsp;part)</span></div>
<div class="block">Convenience method for converting a vector from one lane type
 to another, reshaping as needed when lane sizes change.

 This method returns the value of this expression:
 <code>convertShape(conv,rsp,part)</code>, where <code>conv</code> is
 <code>VectorOperators.Conversion.ofCast(E.class,F.class)</code>.

 <p> If the old and new species have different shape, this is a
 <em>shape-changing</em> operation, and may have special
 implementation costs.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the output species</dd>
<dt>Parameters:</dt>
<dd><code>rsp</code> - the desired output species</dd>
<dd><code>part</code> - the <a href="Vector.html#expansion">part number</a>
        of the result, or zero if neither expanding nor contracting</dd>
<dt>Returns:</dt>
<dd>a vector converted by element type from this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorOperators.Conversion.html#ofCast(java.lang.Class,java.lang.Class)"><code>VectorOperators.Conversion.ofCast(Class,Class)</code></a></li>
<li><a href="#convertShape(jdk.incubator.vector.VectorOperators.Conversion,jdk.incubator.vector.VectorSpecies,int)"><code>convertShape(VectorOperators.Conversion,VectorSpecies,int)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="check(java.lang.Class)">
<h3>check</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">check</span><wbr><span class="parameters">(<a href="../../../../java.base/java/lang/Class.html" title="class in java.lang">Class</a>&lt;F&gt;&nbsp;elementType)</span></div>
<div class="block">Checks that this vector has the given element type,
 and returns this vector unchanged.
 The effect is similar to this pseudocode:
 <code>elementType == species().elementType()
        ? this
        : throw new ClassCastException()</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the required lane type</dd>
<dt>Parameters:</dt>
<dd><code>elementType</code> - the required lane type</dd>
<dt>Returns:</dt>
<dd>the same vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - if the vector has the wrong element type</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="VectorSpecies.html#check(java.lang.Class)"><code>VectorSpecies.check(Class)</code></a></li>
<li><a href="VectorMask.html#check(java.lang.Class)"><code>VectorMask.check(Class)</code></a></li>
<li><a href="#check(jdk.incubator.vector.VectorSpecies)"><code>check(VectorSpecies)</code></a></li>
<li><a href="VectorShuffle.html#check(jdk.incubator.vector.VectorSpecies)"><code>VectorShuffle.check(VectorSpecies)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="check(jdk.incubator.vector.VectorSpecies)">
<h3>check</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="type-parameters">&lt;F&gt;</span>&nbsp;<span class="return-type"><a href="Vector.html" title="class in jdk.incubator.vector">Vector</a>&lt;F&gt;</span>&nbsp;<span class="element-name">check</span><wbr><span class="parameters">(<a href="VectorSpecies.html" title="interface in jdk.incubator.vector">VectorSpecies</a>&lt;F&gt;&nbsp;species)</span></div>
<div class="block">Checks that this vector has the given species,
 and returns this vector unchanged.
 The effect is similar to this pseudocode:
 <code>species == species()
        ? this
        : throw new ClassCastException()</code>.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>F</code> - the boxed element type of the required species</dd>
<dt>Parameters:</dt>
<dd><code>species</code> - the required species</dd>
<dt>Returns:</dt>
<dd>the same vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> - if the vector has the wrong species</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#check(java.lang.Class)"><code>check(Class)</code></a></li>
<li><a href="VectorMask.html#check(jdk.incubator.vector.VectorSpecies)"><code>VectorMask.check(VectorSpecies)</code></a></li>
<li><a href="VectorShuffle.html#check(jdk.incubator.vector.VectorSpecies)"><code>VectorShuffle.check(VectorSpecies)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder)">
<h3>intoMemorySegment</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">intoMemorySegment</span><wbr><span class="parameters">(<a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&nbsp;ms,
 long&nbsp;offset,
 <a href="../../../../java.base/java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;bo)</span></div>
<div class="block">Stores this vector into a <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">memory segment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>
 starting at an offset using explicit byte order.
 <p>
 Bytes are extracted from primitive lane elements according
 to the specified byte ordering.
 The lanes are stored according to their
 <a href="Vector.html#lane-order">memory ordering</a>.
 <p>
 This method behaves as if it calls
 <a href="#intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder,jdk.incubator.vector.VectorMask)"><code>intoMemorySegment()</code></a><sup><a href="#preview-intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder,jdk.incubator.vector.VectorMask)">PREVIEW</a></sup> as follows:
 <pre><code>
 var m = maskAll(true);
 intoMemorySegment(ms, offset, bo, m);
 </code></pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>ms</code> - the memory segment</dd>
<dd><code>offset</code> - the offset into the memory segment</dd>
<dd><code>bo</code> - the intended byte order</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset+N*ESIZE &lt; 0</code>
         or <code>offset+(N+1)*ESIZE &gt; ms.byteSize()</code>
         for any lane <code>N</code> in the vector</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the memory segment is read-only</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the memory segment is a heap segment that is
         not backed by a <code>byte[]</code> array.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if the memory segment's session is not alive,
         or if access occurs from a thread other than the thread owning the session.</dd>
<dt>Since:</dt>
<dd>19</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="intoMemorySegment(java.lang.foreign.MemorySegment,long,java.nio.ByteOrder,jdk.incubator.vector.VectorMask)">
<h3>intoMemorySegment</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">intoMemorySegment</span><wbr><span class="parameters">(<a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>&nbsp;ms,
 long&nbsp;offset,
 <a href="../../../../java.base/java/nio/ByteOrder.html" title="class in java.nio">ByteOrder</a>&nbsp;bo,
 <a href="VectorMask.html" title="class in jdk.incubator.vector">VectorMask</a>&lt;<a href="Vector.html" title="type parameter in Vector">E</a>&gt;&nbsp;m)</span></div>
<div class="block">Stores this vector into a <a href="../../../../java.base/java/lang/foreign/MemorySegment.html" title="interface in java.lang.foreign">memory segment</a><sup><a href="../../../../java.base/java/lang/foreign/MemorySegment.html#preview-java.lang.foreign.MemorySegment">PREVIEW</a></sup>
 starting at an offset using explicit byte order and a mask.
 <p>
 Bytes are extracted from primitive lane elements according
 to the specified byte ordering.
 The lanes are stored according to their
 <a href="Vector.html#lane-order">memory ordering</a>.
 <p>
 The following pseudocode illustrates the behavior, where
 <code>JAVA_E</code> is the layout of the primitive element type, <code>ETYPE</code> is the
 primitive element type, and <code>EVector</code> is the primitive
 vector type for this vector:
 <pre><code>
 ETYPE[] a = this.toArray();
 var slice = ms.asSlice(offset)
 for (int n = 0; n &lt; a.length; n++) {
     if (m.laneIsSet(n)) {
         slice.setAtIndex(ValueLayout.JAVA_E.withBitAlignment(8), n);
     }
 }
 </code></pre></div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>This operation is likely to be more efficient if
 the specified byte order is the same as
 <a href="../../../../java.base/java/nio/ByteOrder.html#nativeOrder()">the platform native order</a>,
 since this method will not need to reorder
 the bytes of lane values.
 In the special case where <code>ETYPE</code> is
 <code>byte</code>, the byte order argument is
 ignored.</dd>
<dt>Parameters:</dt>
<dd><code>ms</code> - the memory segment</dd>
<dd><code>offset</code> - the offset into the memory segment</dd>
<dd><code>bo</code> - the intended byte order</dd>
<dd><code>m</code> - the mask controlling lane selection</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset+N*ESIZE &lt; 0</code>
         or <code>offset+(N+1)*ESIZE &gt; ms.byteSize()</code>
         for any lane <code>N</code> in the vector
         where the mask is set</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if the memory segment is read-only</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the memory segment is a heap segment that is
         not backed by a <code>byte[]</code> array.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if the memory segment's session is not alive,
         or if access occurs from a thread other than the thread owning the session.</dd>
<dt>Since:</dt>
<dd>19</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toArray()">
<h3>toArray</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></span>&nbsp;<span class="element-name">toArray</span>()</div>
<div class="block">Returns a packed array containing all the lane values.
 The array length is the same as the vector length.
 The element type of the array is the same as the element
 type of the vector.
 The array elements are stored in lane order.
 Overrides of this method on subtypes of <code>Vector</code>
 which specify the element type have an accurately typed
 array result.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Usually <a href="FloatVector.html#toArray()">strongly typed access</a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Returns:</dt>
<dd>an accurately typed array containing
         the lane values of this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="ByteVector.html#toArray()"><code>ByteVector.toArray()</code></a></li>
<li><a href="IntVector.html#toArray()"><code>IntVector.toArray()</code></a></li>
<li><a href="DoubleVector.html#toArray()"><code>DoubleVector.toArray()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toIntArray()">
<h3>toIntArray</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int[]</span>&nbsp;<span class="element-name">toIntArray</span>()</div>
<div class="block">Returns an <code>int[]</code> array containing all
 the lane values, converted to the type <code>int</code>.
 The array length is the same as the vector length.
 The array elements are converted as if by casting
 and stored in lane order.

 This operation may fail if the vector element type is <code>
 float</code> or <code>double</code>, when lanes contain fractional or
 out-of-range values.  If any vector lane value is not
 representable as an <code>int</code>, an exception is thrown.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Usually <a href="FloatVector.html#toArray()">strongly typed access</a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Returns:</dt>
<dd>an <code>int[]</code> array containing
         the lane values of this vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if any lane value cannot be represented as an
         <code>int</code> array element</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#toArray()"><code>toArray()</code></a></li>
<li><a href="#toLongArray()"><code>toLongArray()</code></a></li>
<li><a href="#toDoubleArray()"><code>toDoubleArray()</code></a></li>
<li><a href="IntVector.html#toArray()"><code>IntVector.toArray()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toLongArray()">
<h3>toLongArray</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">toLongArray</span>()</div>
<div class="block">Returns a <code>long[]</code> array containing all
 the lane values, converted to the type <code>long</code>.
 The array length is the same as the vector length.
 The array elements are converted as if by casting
 and stored in lane order.

 This operation may fail if the vector element type is <code>
 float</code> or <code>double</code>, when lanes contain fractional or
 out-of-range values.  If any vector lane value is not
 representable as a <code>long</code>, an exception is thrown.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Usually <a href="FloatVector.html#toArray()">strongly typed access</a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Returns:</dt>
<dd>a <code>long[]</code> array containing
         the lane values of this vector</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if any lane value cannot be represented as a
         <code>long</code> array element</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#toArray()"><code>toArray()</code></a></li>
<li><a href="#toIntArray()"><code>toIntArray()</code></a></li>
<li><a href="#toDoubleArray()"><code>toDoubleArray()</code></a></li>
<li><a href="LongVector.html#toArray()"><code>LongVector.toArray()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toDoubleArray()">
<h3>toDoubleArray</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">double[]</span>&nbsp;<span class="element-name">toDoubleArray</span>()</div>
<div class="block">Returns a <code>double[]</code> array containing all
 the lane values, converted to the type <code>double</code>.
 The array length is the same as the vector length.
 The array elements are converted as if by casting
 and stored in lane order.
 This operation can lose precision
 if the vector element type is <code>long</code>.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>Usually <a href="FloatVector.html#toArray()"><code>strongly typed access</code></a>
 is preferable, if you are working with a vector
 subtype that has a known element type.</dd>
<dt>Returns:</dt>
<dd>a <code>double[]</code> array containing
         the lane values of this vector,
         possibly rounded to representable
         <code>double</code> values</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#toArray()"><code>toArray()</code></a></li>
<li><a href="#toIntArray()"><code>toIntArray()</code></a></li>
<li><a href="#toLongArray()"><code>toLongArray()</code></a></li>
<li><a href="DoubleVector.html#toArray()"><code>DoubleVector.toArray()</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toString()">
<h3>toString</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type"><a href="../../../../java.base/java/lang/String.html" title="class in java.lang">String</a></span>&nbsp;<span class="element-name">toString</span>()</div>
<div class="block">Returns a string representation of this vector, of the form
 <code>"[0,1,2...]"</code>, reporting the lane values of this
 vector, in lane order.

 The string is produced as if by a call to
 <a href="../../../../java.base/java/util/Arrays.html#toString(int%5B%5D)"><code>Arrays.toString()</code></a>,
 as appropriate to the array returned by
 <a href="#toArray()"><code>this.toArray()</code></a>.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../../../../java.base/java/lang/Object.html#toString()">toString</a></code>&nbsp;in class&nbsp;<code><a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Returns:</dt>
<dd>a string of the form <code>"[0,1,2...]"</code>
 reporting the lane values of this vector</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="equals(java.lang.Object)">
<h3>equals</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">equals</span><wbr><span class="parameters">(<a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;obj)</span></div>
<div class="block">Indicates whether this vector is identical to some other object.
 Two vectors are identical only if they have the same species
 and same lane values, in the same order.
 <p>The comparison of lane values is produced as if by a call to
 <a href="../../../../java.base/java/util/Arrays.html#equals(int%5B%5D,int%5B%5D)"><code>Arrays.equals()</code></a>,
 as appropriate to the arrays returned by
 <a href="#toArray()"><code>toArray()</code></a> on both vectors.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../../../../java.base/java/lang/Object.html#equals(java.lang.Object)">equals</a></code>&nbsp;in class&nbsp;<code><a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Parameters:</dt>
<dd><code>obj</code> - the reference object with which to compare.</dd>
<dt>Returns:</dt>
<dd>whether this vector is identical to some other object</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#eq(jdk.incubator.vector.Vector)"><code>eq(jdk.incubator.vector.Vector&lt;E&gt;)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hashCode()">
<h3>hashCode</h3>
<div class="member-signature"><span class="modifiers">public abstract</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">hashCode</span>()</div>
<div class="block">Returns a hash code value for the vector.
 based on the lane values and the vector species.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../../../../java.base/java/lang/Object.html#hashCode()">hashCode</a></code>&nbsp;in class&nbsp;<code><a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Returns:</dt>
<dd>a hash code value for this vector</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="../../../../java.base/java/lang/Object.html#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a></li>
<li><a href="../../../../java.base/java/lang/System.html#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase20&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2022, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java20speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <br><strong>DRAFT 20-internal-2022-07-19-1311514.jlaskey...</strong> <!-- Version 20-internal-2022-07-19-1311514.jlaskey... --></small></p>
</footer>
</div>
</div>
</body>
</html>
